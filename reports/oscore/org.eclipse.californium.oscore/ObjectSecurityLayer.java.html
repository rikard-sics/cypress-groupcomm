<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObjectSecurityLayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">ObjectSecurityLayer.java</span></div><h1>ObjectSecurityLayer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.eclipse.californium.core.coap.EmptyMessage;
import org.eclipse.californium.core.coap.Message;
import org.eclipse.californium.core.coap.MessageObserverAdapter;
import org.eclipse.californium.core.coap.OptionSet;
import org.eclipse.californium.core.coap.Request;
import org.eclipse.californium.core.coap.Response;
import org.eclipse.californium.core.coap.Token;

import org.eclipse.californium.core.coap.CoAP.ResponseCode;
import org.eclipse.californium.core.network.Exchange;
import org.eclipse.californium.core.network.stack.AbstractLayer;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.oscore.ContextRederivation.PHASE;
import org.eclipse.californium.oscore.group.GroupSenderCtx;
import org.eclipse.californium.oscore.group.OptionEncoder;

/**
 * 
 * Applies OSCORE mechanics at stack layer.
 *
 */
public class ObjectSecurityLayer extends AbstractLayer {

	/**
	 * The logger
	 */
<span class="fc" id="L50">	private static final Logger LOGGER = LoggerFactory.getLogger(ObjectSecurityLayer.class);</span>

	private final OSCoreCtxDB ctxDb;

<span class="fc" id="L54">	public ObjectSecurityLayer(OSCoreCtxDB ctxDb) {</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">		if (ctxDb == null) {</span>
<span class="nc" id="L56">			throw new NullPointerException(&quot;OSCoreCtxDB must be provided!&quot;);</span>
		}
<span class="fc" id="L58">		this.ctxDb = ctxDb;</span>
<span class="fc" id="L59">	}</span>

	/**
	 * Encrypt an outgoing request using the OSCore context.
	 * 
	 * @param message the message
	 * @param ctxDb the context database used
	 * 
	 * @return the encrypted message
	 * 
	 * @throws OSException error while encrypting request
	 */
	public static Request prepareSend(OSCoreCtxDB ctxDb, Request message) throws OSException {
<span class="fc" id="L72">		return RequestEncryptor.encrypt(ctxDb, message);</span>
	}

	/**
	 * Encrypt an outgoing response using the OSCore context.
	 * 
	 * @param ctxDb the OSCore context DB
	 * @param message the message
	 * @param ctx the OSCore context
	 * @param newPartialIV whether to use a new partial IV or not
	 * @param outerBlockwise whether the block-wise options should be encrypted
	 * @param requestSequenceNr sequence number (Partial IV) from the request
	 *            (if encrypting a response)
	 * @param requestOption the OSCORE option of the corresponding request
	 * 
	 * @return the encrypted message
	 * 
	 * @throws OSException error while encrypting response
	 */
	public static Response prepareSend(OSCoreCtxDB ctxDb, Response message, OSCoreCtx ctx, final boolean newPartialIV,
			boolean outerBlockwise, int requestSequenceNr, byte[] requestOption) throws OSException {
<span class="fc" id="L93">		return ResponseEncryptor.encrypt(ctxDb, message, ctx, newPartialIV, outerBlockwise, requestSequenceNr, requestOption);</span>
	}

	/**
	 * Decrypt an incoming request using the right OSCore context
	 *
	 * @param ctxDb the context database used
	 * @param request the incoming request
	 * @param ctx the OSCore context
	 * 
	 * @return the decrypted and verified request
	 * 
	 * @throws CoapOSException error while decrypting request
	 */
	public static Request prepareReceive(OSCoreCtxDB ctxDb, Request request, OSCoreCtx ctx) throws CoapOSException {
<span class="fc" id="L108">		return RequestDecryptor.decrypt(ctxDb, request, ctx);</span>
	}

	/**
	 * Decrypt an incoming response using the right OSCore context
	 *
	 * @param ctxDb the context database used
	 * @param response the incoming request
	 * @param requestSequenceNr sequence number (Partial IV) from the request
	 *            (if decrypting a response)
	 * 
	 * @return the decrypted and verified response
	 * 
	 * @throws OSException error while decrypting response
	 */
	public static Response prepareReceive(OSCoreCtxDB ctxDb, Response response, int requestSequenceNr)
			throws OSException {
<span class="fc" id="L125">		return ResponseDecryptor.decrypt(ctxDb, response, requestSequenceNr);</span>
	}

	@Override
	public void sendRequest(final Exchange exchange, final Request request) {
<span class="fc" id="L130">		Request req = request;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if (shouldProtectRequest(request)) {</span>
			try {
				// Handle outgoing requests for more data from a responder that
				// is responding with outer block-wise. These requests should
				// not be processed with OSCORE.
<span class="fc" id="L136">				Response response = exchange.getCurrentResponse();</span>
<span class="pc bpc" id="L137" title="1 of 4 branches missed.">				if (request.getOptions().hasBlock2() &amp;&amp; response != null) {</span>
<span class="fc" id="L138">					final OSCoreCtx ctx = ctxDb.getContextByToken(response.getToken());</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">					if (ctx != null) {</span>
<span class="fc" id="L140">						request.addMessageObserver(0, new MessageObserverAdapter() {</span>

							@Override
							public void onReadyToSend() {
<span class="fc" id="L144">								ctxDb.addContext(request.getToken(), ctx);</span>
<span class="fc" id="L145">							}</span>
						});
<span class="fc" id="L147">						super.sendRequest(exchange, request);</span>
<span class="fc" id="L148">						return;</span>
					}
				}

				String uri;
<span class="fc bfc" id="L153" title="All 2 branches covered.">				if (request.getOptions().hasProxyUri()) {</span>
<span class="fc" id="L154">					uri = request.getOptions().getProxyUri();</span>
				} else {
<span class="fc" id="L156">					uri = request.getURI();</span>
				}
				
				// Check if parameters in the option was set by the application
<span class="fc bfc" id="L160" title="All 2 branches covered.">				if (request.getOptions().getOscore().length != 0) {</span>
					// Use the URI from the option to find the correct context
<span class="fc" id="L162">					uri = OptionEncoder.getContextUri(request.getOptions().getOscore());</span>
				}

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">				if (uri == null) {</span>
<span class="nc" id="L166">					LOGGER.error(ErrorDescriptions.URI_NULL);</span>
<span class="nc" id="L167">					throw new OSException(ErrorDescriptions.URI_NULL);</span>
				}

<span class="fc" id="L170">				OSCoreCtx ctx = ctxDb.getContext(uri);</span>

<span class="pc bpc" id="L172" title="1 of 2 branches missed.">				if (ctx == null) {</span>
<span class="nc" id="L173">					LOGGER.error(ErrorDescriptions.CTX_NULL);</span>
<span class="nc" id="L174">					throw new OSException(ErrorDescriptions.CTX_NULL);</span>
				}

				// Initiate context re-derivation procedure if flag is set
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">				if (ctx.getContextRederivationPhase() == PHASE.CLIENT_INITIATE) {</span>
<span class="nc" id="L179">					throw new IllegalStateException(&quot;must be handled in ObjectSecurityContextLayer!&quot;);</span>
				}

				/*
				 * Sets an operator on the exchange. This operator will in
				 * turn set information about the OSCORE context used in the
				 * endpoint context that will be created after the request is sent.
				 */
<span class="fc" id="L187">				OSCoreEndpointContextInfo.sendingRequest(ctx, exchange);</span>

<span class="fc" id="L189">				final Request preparedRequest = prepareSend(ctxDb, request);</span>
<span class="fc" id="L190">				final OSCoreCtx finalCtx = ctxDb.getContext(uri);</span>

<span class="fc" id="L192">				exchange.setCryptographicContextID(preparedRequest.getOptions().getOscore());</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">				if (outgoingExceedsMaxUnfragSize(preparedRequest, false, ctx.getMaxUnfragmentedSize())) {</span>
<span class="fc" id="L195">					throw new IllegalStateException(&quot;outgoing request is exceeding the MAX_UNFRAGMENTED_SIZE!&quot;);</span>
				}

<span class="fc" id="L198">				preparedRequest.addMessageObserver(0, new MessageObserverAdapter() {</span>

					// TODO: New observer for more Token handling?

					@Override
					public void onReadyToSend() {
<span class="fc" id="L204">						Token token = preparedRequest.getToken();</span>

						// add at head of message observers to update
						// the token of the original request first,
						// before calling other message observers!
<span class="fc bfc" id="L209" title="All 2 branches covered.">						if (request.getToken() == null) {</span>
<span class="fc" id="L210">							request.setToken(token);</span>
						}

<span class="pc bpc" id="L213" title="1 of 4 branches missed.">						if (!request.hasMID() &amp;&amp; preparedRequest.hasMID()) {</span>
<span class="fc" id="L214">							request.setMID(preparedRequest.getMID());</span>
						}

						// Clear long exchanges for this Token
<span class="fc bfc" id="L218" title="All 2 branches covered.">						if (finalCtx.isGroupContext()) {</span>
<span class="fc" id="L219">							((GroupSenderCtx) finalCtx).getCommonCtx().longExchanges</span>
<span class="fc" id="L220">									.remove(new ByteId(token.getBytes()));</span>
						}

<span class="fc" id="L223">						ctxDb.addContext(token, finalCtx);</span>
<span class="fc" id="L224">					}</span>
				});

<span class="fc" id="L227">				req = preparedRequest;</span>
<span class="fc" id="L228">				exchange.setCryptographicContextID(req.getOptions().getOscore());</span>

<span class="nc" id="L230">			} catch (OSException e) {</span>
<span class="nc" id="L231">				LOGGER.error(&quot;Error sending request: {}&quot;, e.getMessage());</span>
<span class="nc" id="L232">				return;</span>
<span class="nc" id="L233">			} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L234">				LOGGER.error(&quot;Unable to send request because of illegal argument: {}&quot;, e.getMessage());</span>
<span class="nc" id="L235">				return;</span>
<span class="fc" id="L236">			}</span>
		}
<span class="fc" id="L238">		LOGGER.trace(&quot;Request: {}&quot;, exchange.getRequest());</span>
<span class="fc" id="L239">		super.sendRequest(exchange, req);</span>
<span class="fc" id="L240">	}</span>

	@Override
	public void sendResponse(Exchange exchange, Response response) {
		/* If the request contained the Observe option always add a partial IV to the response.
		 * A partial IV will also be added if the responsesIncludePartialIV flag is set in the context. */
		boolean addPartialIV;
		
		/*
		 * If the original request used outer block-wise options so should the
		 * response. (They are not encrypted but external unprotected options.)
		 */
		boolean outerBlockwise;

<span class="fc bfc" id="L254" title="All 2 branches covered.">		if (shouldProtectResponse(exchange)) {</span>
			// If the current block-request still has a non-empty OSCORE option it
			// means it was not unprotected by OSCORE as and individual request.
			// Rather it was not processed by OSCORE until after being re-assembled
			// by the block-wise layer. Thus the response should use outer block options.
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">			outerBlockwise = exchange.getCurrentRequest().getOptions().hasOscore()</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">					&amp;&amp; exchange.getCurrentRequest().getOptions().getOscore().length != 0;</span>

			try {
				// Retrieve the context
				// TODO: Don't just use Token as key, also use the addressing
				// information. Maybe consider using Token and RID + ID Context
				// instead. Need to change the map to take 3 things instead of
				// just Token.
				//
				// Or actually use the requestOption KID and KID Context
				// directly. (Indirectly using the Token).
<span class="fc" id="L271">				OSCoreCtx ctx = ctxDb.getContextByToken(exchange.getCurrentRequest().getToken());</span>
<span class="pc bpc" id="L272" title="2 of 6 branches missed.">				addPartialIV = (ctx !=null &amp;&amp; ctx.getResponsesIncludePartialIV()) || exchange.getRequest().getOptions().hasObserve();</span>

				// Parse the OSCORE option from the corresponding request
<span class="fc" id="L275">				byte[] requestOption = exchange.getCryptographicContextID();</span>
<span class="fc" id="L276">				OscoreOptionDecoder optionDecoder = new OscoreOptionDecoder(requestOption);</span>
<span class="fc" id="L277">				int requestSequenceNumber = optionDecoder.getSequenceNumber();</span>

<span class="fc" id="L279">				Response preparedResponse = prepareSend(ctxDb, response, ctx, addPartialIV, outerBlockwise,</span>
						requestSequenceNumber, requestOption);

<span class="pc bpc" id="L282" title="1 of 2 branches missed.">				if (outgoingExceedsMaxUnfragSize(preparedResponse, outerBlockwise, ctx.getMaxUnfragmentedSize())) {</span>
<span class="nc" id="L283">					Response error = new Response(ResponseCode.INTERNAL_SERVER_ERROR, true);</span>
<span class="nc" id="L284">					error.setDestinationContext(exchange.getCurrentRequest().getSourceContext());</span>
<span class="nc" id="L285">					super.sendResponse(exchange, error);</span>
<span class="nc" id="L286">					throw new IllegalStateException(&quot;outgoing response is exceeding the MAX_UNFRAGMENTED_SIZE!&quot;);</span>
				}

<span class="fc" id="L289">				response = preparedResponse;</span>
<span class="fc" id="L290">				exchange.setResponse(response);</span>
<span class="nc" id="L291">			} catch (OSException e) {</span>
<span class="nc" id="L292">				LOGGER.error(&quot;Error sending response: {}&quot;, e.getMessage());</span>
<span class="nc" id="L293">				return;</span>
<span class="fc" id="L294">			}</span>
		}

		// Remove token after response is transmitted, unless ongoing Observe.
		// Takes token from corresponding request
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">		if (response.getOptions().hasObserve() == false || exchange.getRequest().isObserveCancel()) {</span>
<span class="fc" id="L300">			ctxDb.removeToken(exchange.getCurrentRequest().getToken());</span>
		}

<span class="fc" id="L303">		super.sendResponse(exchange, response);</span>
<span class="fc" id="L304">	}</span>

	@Override
	public void sendEmptyMessage(Exchange exchange, EmptyMessage message) {
<span class="nc" id="L308">		super.sendEmptyMessage(exchange, message);</span>
<span class="nc" id="L309">	}</span>

	@Override
	public void receiveRequest(Exchange exchange, Request request) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">		if (isProtected(request)) {</span>

<span class="fc" id="L315">			OSCoreCtx ctx = null;</span>
			try {
				// Retrieve the OSCORE context associated with this RID and ID
				// Context
<span class="fc" id="L319">				OscoreOptionDecoder optionDecoder = new OscoreOptionDecoder(request.getOptions().getOscore());</span>
<span class="fc" id="L320">				byte[] rid = optionDecoder.getKid();</span>
<span class="fc" id="L321">				byte[] IDContext = optionDecoder.getIdContext();</span>

<span class="fc" id="L323">				ctx = ctxDb.getContext(rid, IDContext);</span>
<span class="fc" id="L324">			} catch (CoapOSException e) {</span>
<span class="fc" id="L325">				LOGGER.error(&quot;Error while receiving OSCore request: {}&quot;, e.getMessage());</span>
				Response error;
<span class="fc" id="L327">				error = CoapOSExceptionHandler.manageError(e, request);</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">				if (error != null) {</span>
<span class="fc" id="L329">					super.sendResponse(exchange, error);</span>
				}
<span class="fc" id="L331">				return;</span>
<span class="fc" id="L332">			}</span>

			// For OSCORE-protected requests with the outer block1-option let
			// them pass through to be re-assembled by the block-wise layer
<span class="fc bfc" id="L336" title="All 2 branches covered.">			if (request.getOptions().hasBlock1()) {</span>

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">				if (request.getMaxResourceBodySize() == 0) {</span>
<span class="fc" id="L339">					int maxPayloadSize = getIncomingMaxUnfragSize(request, ctx);</span>
<span class="fc" id="L340">					request.setMaxResourceBodySize(maxPayloadSize);</span>
				}

<span class="fc" id="L343">				super.receiveRequest(exchange, request);</span>
<span class="fc" id="L344">				return;</span>
			}

			byte[] requestOscoreOption;
			try {
<span class="fc" id="L349">				requestOscoreOption = request.getOptions().getOscore();</span>
<span class="fc" id="L350">				request = prepareReceive(ctxDb, request, ctx);</span>
<span class="fc" id="L351">				request.getOptions().setOscore(Bytes.EMPTY);</span>
<span class="fc" id="L352">				exchange.setRequest(request);</span>
<span class="fc" id="L353">			} catch (CoapOSException e) {</span>
<span class="fc" id="L354">				LOGGER.error(&quot;Error while receiving OSCore request: {}&quot;, e.getMessage());</span>
				Response error;
<span class="fc" id="L356">				error = CoapOSExceptionHandler.manageError(e, request);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">				if (error != null) {</span>
<span class="fc" id="L358">					super.sendResponse(exchange, error);</span>
				}
<span class="fc" id="L360">				return;</span>
<span class="fc" id="L361">			}</span>

<span class="fc" id="L363">			exchange.setCryptographicContextID(requestOscoreOption);</span>
		}
<span class="fc" id="L365">		super.receiveRequest(exchange, request);</span>
<span class="fc" id="L366">	}</span>

	//Always accepts unprotected responses, which is needed for reception of error messages
	@Override
	public void receiveResponse(Exchange exchange, Response response) {
<span class="fc" id="L371">		Request request = exchange.getCurrentRequest();</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">		if (request == null) {</span>
<span class="nc" id="L373">			LOGGER.error(&quot;No request tied to this response&quot;);</span>
<span class="nc" id="L374">			return;</span>
		}

		try {
			//Printing of status information.
			//Warns when expecting OSCORE response but unprotected response is received
<span class="fc" id="L380">			boolean expectProtectedResponse = responseShouldBeProtected(exchange, response);</span>
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">			if (!isProtected(response) &amp;&amp; expectProtectedResponse) {</span>
<span class="fc" id="L382">				LOGGER.info(&quot;Incoming response is NOT OSCORE protected but is expected to be!&quot;);</span>
<span class="pc bpc" id="L383" title="2 of 4 branches missed.">			} else if (isProtected(response) &amp;&amp; expectProtectedResponse) {</span>
<span class="fc" id="L384">				LOGGER.debug(&quot;Incoming response is OSCORE protected&quot;);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			} else if (isProtected(response)) {</span>
<span class="nc" id="L386">				LOGGER.warn(&quot;Incoming response is OSCORE protected but it should not be&quot;);</span>
			}

			// For OSCORE-protected response with the outer block2-option let
			// them pass through to be re-assembled by the block-wise layer
<span class="fc bfc" id="L391" title="All 2 branches covered.">			if (response.getOptions().hasBlock2()) {</span>

<span class="pc bpc" id="L393" title="1 of 2 branches missed.">				if (response.getMaxResourceBodySize() == 0) {</span>
<span class="fc" id="L394">					int maxPayloadSize = getIncomingMaxUnfragSize(response, ctxDb);</span>
<span class="fc" id="L395">					response.setMaxResourceBodySize(maxPayloadSize);</span>
				}

<span class="fc" id="L398">				super.receiveResponse(exchange, response);</span>
<span class="fc" id="L399">				return;</span>
			}

			//If response is protected with OSCORE parse it first with prepareReceive
<span class="fc bfc" id="L403" title="All 2 branches covered.">			if (isProtected(response)) {</span>
				// Parse the OSCORE option from the corresponding request
<span class="fc" id="L405">				OscoreOptionDecoder optionDecoder = new OscoreOptionDecoder(exchange.getCryptographicContextID());</span>
<span class="fc" id="L406">				int requestSequenceNumber = optionDecoder.getSequenceNumber();</span>

<span class="fc" id="L408">				response = prepareReceive(ctxDb, response, requestSequenceNumber);</span>
			}
<span class="nc" id="L410">		} catch (OSException e) {</span>
<span class="nc" id="L411">			LOGGER.error(&quot;Error while receiving OSCore response: {}&quot;, e.getMessage());</span>
<span class="nc" id="L412">			EmptyMessage error = CoapOSExceptionHandler.manageError(e, response);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">			if (error != null) {</span>
<span class="nc" id="L414">				sendEmptyMessage(exchange, error);</span>
			}
<span class="nc" id="L416">			return;</span>
<span class="fc" id="L417">		}</span>
		
		// Remove token if this is an incoming response to an Observe
		// cancellation request
<span class="fc bfc" id="L421" title="All 2 branches covered.">		if (exchange.getRequest().isObserveCancel()) {</span>
<span class="fc" id="L422">			ctxDb.removeToken(response.getToken());</span>
		}
		
<span class="fc" id="L425">		super.receiveResponse(exchange, response);</span>
<span class="fc" id="L426">	}</span>

	@Override
	public void receiveEmptyMessage(Exchange exchange, EmptyMessage message) {
<span class="nc" id="L430">		super.receiveEmptyMessage(exchange, message);</span>
<span class="nc" id="L431">	}</span>

	private static boolean shouldProtectResponse(Exchange exchange) {
<span class="fc bfc" id="L434" title="All 2 branches covered.">		return exchange.getCryptographicContextID() != null;</span>
	}

	//Method that checks if a response is expected to be protected with OSCORE
	private boolean responseShouldBeProtected(Exchange exchange, Response response) throws OSException {
<span class="fc" id="L439">		Request request = exchange.getCurrentRequest();</span>
<span class="fc" id="L440">		OptionSet options = request.getOptions();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">		if (exchange.getCryptographicContextID() == null) {</span>
<span class="pc bpc" id="L442" title="2 of 4 branches missed.">			if (response.getOptions().hasObserve() &amp;&amp; request.getOptions().hasObserve()) {</span>
				// Since the exchange object has been re-created the
				// cryptographic id doesn't exist
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">				if (options.hasOscore()) {</span>
<span class="fc" id="L446">					exchange.setCryptographicContextID(options.getOscore());</span>
				}
			}
		}
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">		return exchange.getCryptographicContextID() != null;</span>
	}

	private static boolean shouldProtectRequest(Request request) {
<span class="fc" id="L454">		OptionSet options = request.getOptions();</span>
<span class="fc" id="L455">		return options.hasOscore();</span>

	}

	private static boolean isProtected(Message message) {
<span class="fc bfc" id="L460" title="All 2 branches covered.">		return message.getOptions().getOscore() != null;</span>
	}

	/**
	 * Check if a message being sent exceeds the MAX_UNFRAGMENTED_SIZE and is
	 * not using inner block-wise. If so it should not be sent.
	 * 
	 * @param message the CoAP message
	 * @param outerBlockwise {@code true}, for outer, {@code false}, for inner blockwise
	 * @param maxUnfragmentedSize the MAX_UNFRAGMENTED_SIZE value
	 * 
	 * @return if the message exceeds the MAX_UNFRAGMENTED_SIZE
	 */
	private boolean outgoingExceedsMaxUnfragSize(Message message, boolean outerBlockwise,
			int maxUnfragmentedSize) {

<span class="fc bfc" id="L476" title="All 2 branches covered.">		boolean usesInnerBlockwise = (message.getOptions().hasBlock1() == true</span>
<span class="pc bpc" id="L477" title="2 of 4 branches missed.">				|| message.getOptions().hasBlock2() == true) &amp;&amp; outerBlockwise == false;</span>

<span class="pc bpc" id="L479" title="1 of 4 branches missed.">		if (message.getPayloadSize() &gt; maxUnfragmentedSize &amp;&amp; usesInnerBlockwise == false) {</span>
<span class="fc" id="L480">			return true;</span>
		} else {
<span class="fc" id="L482">			return false;</span>
		}

	}

	/**
	 * Gets the MAX_UNFRAGMENTED_SIZE size for an incoming block-wise transfer.
	 * If outer block-wise is used this value will be set using
	 * setMaxResourceBodySize on the incoming request or response and enforced
	 * in the BlockwiseLayer. Reception of messages where the cumulative payload
	 * size exceeds this value will be aborted.
	 * 
	 * @param message the CoAP message
	 * @param ctx the context used
	 * 
	 * @return the MAX_UNFRAGMENTED_SIZE value to be used
	 */
	private int getIncomingMaxUnfragSize(Message message, OSCoreCtx ctx) {

		// No limit if no context is found. A null context will be handled later
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">		if (ctx == null) {</span>
<span class="nc" id="L503">			return 0;</span>
		} else {
<span class="fc" id="L505">			return ctx.getMaxUnfragmentedSize();</span>
		}

	}

	/**
	 * Separate version of method for handling responses.
	 * 
	 * @param message the CoAP message
	 * @param ctxDb the context database used
	 * @return the MAX_UNFRAGMENTED_SIZE value to be used
	 */
	private int getIncomingMaxUnfragSize(Message message, OSCoreCtxDB ctxDb) {
<span class="fc" id="L518">		OSCoreCtx ctx = null;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">		if (message instanceof Response) {</span>
<span class="fc" id="L520">			ctx = ctxDb.getContextByToken(message.getToken());</span>
		}

<span class="fc" id="L523">		return getIncomingMaxUnfragSize(message, ctx);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>