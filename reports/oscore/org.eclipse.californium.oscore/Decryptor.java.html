<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Decryptor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">Decryptor.java</span></div><h1>Decryptor.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.nio.ByteBuffer;
import java.util.Arrays;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.eclipse.californium.core.Utils;
import org.eclipse.californium.core.coap.CoAP;
import org.eclipse.californium.core.coap.Message;
import org.eclipse.californium.core.coap.OptionSet;
import org.eclipse.californium.core.coap.Request;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.EncryptCommon;

import com.upokecenter.cbor.CBORObject;

import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.Attribute;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.CounterSign1;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.oscore.ContextRederivation.PHASE;
import org.eclipse.californium.cose.OneKey;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.oscore.group.GroupRecipientCtx;

/**
 * 
 * Gathers generalized methods for decryption and decompression of OSCORE
 * protected messages. Also provides decoding of the encoded OSCORE option
 *
 */
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">public abstract class Decryptor {</span>
	/**
	 * Java 1.6 compatibility.
	 */
	public static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE;

	/**
	 * The logger
	 */
<span class="fc" id="L63">	private static final Logger LOGGER = LoggerFactory.getLogger(Decryptor.class);</span>

	/**
	 * Empty option set
	 */
<span class="fc" id="L68">	protected static final OptionSet EMPTY = new OptionSet();</span>

	/**
	 * Decrypts and decodes the message.
	 * 
	 * @param enc the COSE structure
	 * @param message the message
	 * @param ctx the OSCore context
	 * @param seqByToken the sequence number
	 * 
	 * @return the decrypted plaintext
	 *
	 * @throws OSException if decryption or decoding fails
	 */
	protected static byte[] decryptAndDecode(Encrypt0Message enc, Message message, OSCoreCtx ctx, Integer seqByToken)
			throws OSException {
<span class="fc" id="L84">		int seq = -2;</span>
<span class="fc" id="L85">		boolean isRequest = message instanceof Request;</span>
<span class="fc" id="L86">		byte[] nonce = null;</span>
<span class="fc" id="L87">		byte[] partialIV = null;</span>
<span class="fc" id="L88">		byte[] aad = null;</span>

<span class="fc" id="L90">		AlgorithmID decryptionAlg = ctx.getAlg();</span>
<span class="fc" id="L91">		CBORObject piv = enc.findAttribute(HeaderKeys.PARTIAL_IV);</span>

		// Adjust nonce/IV and Common IV lengths depending on algorithm used
<span class="fc" id="L94">		boolean groupModeMessage = OptionJuggle.getGroupModeBit(message.getOptions().getOscore());</span>
<span class="fc" id="L95">		int nonceLength = ctx.getIVLength();</span>
<span class="fc" id="L96">		byte[] commonIV = ctx.getCommonIV();</span>
<span class="fc bfc" id="L97" title="All 4 branches covered.">		if (ctx.isGroupContext() &amp;&amp; groupModeMessage) {</span>
<span class="fc" id="L98">			int algGroupEncIvLen = EncryptCommon.getIvLength(((GroupRecipientCtx) ctx).getAlgGroupEnc());</span>
<span class="fc" id="L99">			nonceLength = algGroupEncIvLen;</span>
<span class="fc" id="L100">			commonIV = Arrays.copyOfRange(ctx.getCommonIV(), 0, nonceLength);</span>
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">		} else if (ctx.isGroupContext() &amp;&amp; !groupModeMessage) {</span>
<span class="fc" id="L102">			int algIvLen = EncryptCommon.getIvLength(((GroupRecipientCtx) ctx).getAlg());</span>
<span class="fc" id="L103">			nonceLength = algIvLen;</span>
<span class="fc" id="L104">			commonIV = Arrays.copyOfRange(ctx.getCommonIV(), 0, nonceLength);</span>
		}
<span class="fc" id="L106">		System.out.println(&quot;Decryption nonce length: &quot; + nonceLength);</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (isRequest) {</span>

<span class="pc bpc" id="L110" title="1 of 2 branches missed.">			if (piv == null) {</span>
<span class="nc" id="L111">				LOGGER.error(&quot;Decryption failed: no partialIV in request&quot;);</span>
<span class="nc" id="L112">				throw new OSException(ErrorDescriptions.DECRYPTION_FAILED);</span>
			} else {

<span class="fc" id="L115">				partialIV = piv.GetByteString();</span>
<span class="fc" id="L116">				partialIV = expandToIntSize(partialIV);</span>
<span class="fc" id="L117">				seq = ByteBuffer.wrap(partialIV).getInt();</span>
				
				//Note that the code below can throw an OSException when replays are detected
<span class="fc" id="L120">				ctx.checkIncomingSeq(seq);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">				if (ctx.isGroupContext()) {</span>
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">					assert ctx instanceof GroupRecipientCtx;</span>
				}

<span class="fc" id="L125">				nonce = OSSerializer.nonceGeneration(partialIV, ctx.getRecipientId(), commonIV,</span>
						nonceLength);
<span class="fc" id="L127">				aad = OSSerializer.serializeAAD(CoAP.VERSION, ctx.getAlg(), seq, ctx.getRecipientId(), message.getOptions());</span>
			}
		} else {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">			if (seqByToken == null) {</span>
<span class="nc" id="L131">				LOGGER.error(&quot;Decryption failed: the arrived response is not connected to a request we sent&quot;);</span>
<span class="nc" id="L132">				throw new OSException(ErrorDescriptions.DECRYPTION_FAILED);</span>
			}
		
			//Sequence number taken from original request
<span class="fc" id="L136">			seq = seqByToken;</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">			if (piv == null) {</span>
				//Use the partialIV that arrived in the original request (response has no partial IV)

<span class="fc" id="L141">				partialIV = ByteBuffer.allocate(INTEGER_BYTES).putInt(seq).array();</span>
<span class="fc" id="L142">				nonce = OSSerializer.nonceGeneration(partialIV, ctx.getSenderId(), commonIV,</span>
						nonceLength);
			} else {
				//Since the response contains a partial IV use it for nonce calculation

<span class="fc" id="L147">				partialIV = piv.GetByteString();</span>
<span class="fc" id="L148">				partialIV = expandToIntSize(partialIV);</span>
<span class="fc" id="L149">				nonce = OSSerializer.nonceGeneration(partialIV, ctx.getRecipientId(), commonIV,</span>
						nonceLength);
			}

			//Nonce calculation uses partial IV in response (if present).
			//AAD calculation always uses partial IV (seq. nr.) of original request.  
<span class="fc" id="L155">			aad = OSSerializer.serializeAAD(CoAP.VERSION, ctx.getAlg(), seq, ctx.getSenderId(), message.getOptions());</span>
		}

		// Warning: Using algos without integrity in pairwise mode
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">		if (decryptionAlg.getTagSize() == 0 &amp;&amp; !groupModeMessage) {</span>
<span class="fc" id="L160">			LOGGER.warn(&quot;Using an algorithm without integrity protection in pairwise mode!&quot;);</span>
		}

<span class="fc bfc" id="L163" title="All 2 branches covered.">		if (ctx.getContextRederivationPhase() == PHASE.SERVER_PHASE_1) {</span>
<span class="fc" id="L164">			ctx.setNonceHandover(nonce);</span>
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">		} else if (ctx.getContextRederivationPhase() == PHASE.CLIENT_PHASE_2 &amp;&amp; ctx.getNonceHandover() != null) {</span>
<span class="fc" id="L166">			nonce = ctx.getNonceHandover();</span>
		}

<span class="fc" id="L169">		System.out.println(&quot;Decrypting incoming &quot; + message.getClass().getSimpleName());</span>
<span class="fc" id="L170">		System.out.println(&quot;PartialIV &quot; + Utils.toHexString(partialIV));</span>
<span class="fc" id="L171">		System.out.println(&quot;Nonce &quot; + Utils.toHexString(nonce));</span>
<span class="fc" id="L172">		System.out.println(&quot;Common IV &quot; + Utils.toHexString(ctx.getCommonIV()));</span>
		
<span class="fc" id="L174">		byte[] plaintext = null;</span>
<span class="fc" id="L175">		byte[] key = ctx.getRecipientKey();</span>

		// Handle Group OSCORE messages
<span class="fc" id="L178">		CounterSign1 sign = null;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		if (ctx.isGroupContext()) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">			LOGGER.debug(&quot;Decrypting incoming &quot; + message.getClass().getSimpleName()</span>
					+ &quot; using Group OSCORE. Pairwise mode: &quot; + !groupModeMessage);

			// Update external AAD value for Group OSCORE
<span class="fc" id="L184">			aad = OSSerializer.updateAADForGroup(ctx, aad, message);</span>

<span class="fc bfc" id="L186" title="All 2 branches covered.">			System.out.println(&quot;Decrypting incoming &quot; + message.getClass().getSimpleName() + &quot;, using pairwise mode: &quot;</span>
					+ !groupModeMessage);
<span class="fc" id="L188">			System.out.println(&quot;Decrypting incoming &quot; + message.getClass().getSimpleName() + &quot; with AAD &quot;</span>
<span class="fc" id="L189">					+ Utils.toHexString(aad));</span>

<span class="fc" id="L191">			System.out.println(&quot;Decrypting incoming &quot; + message.getClass().getSimpleName() + &quot; with nonce &quot;</span>
<span class="fc" id="L192">					+ Utils.toHexString(nonce));</span>

			// If group mode is used prepare the signature checking
<span class="fc bfc" id="L195" title="All 2 branches covered.">			if (groupModeMessage) {</span>
<span class="fc" id="L196">				decryptionAlg = ((GroupRecipientCtx) ctx).getAlgGroupEnc();</span>
				// Decrypt the signature.
<span class="fc bfc" id="L198" title="All 4 branches covered.">				if (isRequest || piv != null) {</span>
<span class="fc" id="L199">					byte[] pivFromMessage = enc.findAttribute(HeaderKeys.PARTIAL_IV).GetByteString();</span>
<span class="fc" id="L200">					decryptSignature(enc, sign, (GroupRecipientCtx) ctx, pivFromMessage, ctx.getRecipientId(),</span>
							isRequest);
<span class="fc" id="L202">				} else {</span>
<span class="fc" id="L203">					byte[] pivFromOther = OSSerializer.stripZeroes(ByteBuffer.allocate(5).putInt(seq).array());</span>
<span class="fc" id="L204">					decryptSignature(enc, sign, (GroupRecipientCtx) ctx, pivFromOther, ctx.getSenderId(), isRequest);</span>
				}

<span class="fc" id="L207">				sign = prepareCheckSignature(enc, ctx, aad, message);</span>
			} else {
				// If this is a pairwise response use the pairwise key
<span class="fc" id="L210">				key = ((GroupRecipientCtx) ctx).getPairwiseRecipientKey();</span>
			}
		}

<span class="fc" id="L214">		System.out.println(&quot;AAD &quot; + Utils.toHexString(aad));</span>
<span class="fc" id="L215">		System.out.println(&quot;Recipient Key &quot; + Utils.toHexString(ctx.getRecipientKey()));</span>
<span class="fc" id="L216">		System.out.println(&quot;Key used &quot; + Utils.toHexString(key));</span>

<span class="fc" id="L218">		enc.setExternal(aad);</span>

		// Check signature before decrypting
<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (groupModeMessage) {</span>
			// Verify the signature
<span class="fc" id="L223">			boolean signatureCorrect = checkSignature(enc, sign);</span>
<span class="fc" id="L224">			LOGGER.debug(&quot;Signature verification succeeded: &quot; + signatureCorrect);</span>
		}

		try {
			// TODO: Get and set Recipient ID (KID) here too?
<span class="fc" id="L229">			enc.addAttribute(HeaderKeys.Algorithm, decryptionAlg.AsCBOR(), Attribute.DO_NOT_SEND);</span>
<span class="fc" id="L230">			enc.addAttribute(HeaderKeys.IV, CBORObject.FromObject(nonce), Attribute.DO_NOT_SEND);</span>
<span class="fc" id="L231">			plaintext = enc.decrypt(key);</span>

<span class="fc" id="L233">		} catch (CoseException e) {</span>
<span class="fc" id="L234">			String details = ErrorDescriptions.DECRYPTION_FAILED + &quot; &quot; + e.getMessage();</span>
<span class="fc" id="L235">			LOGGER.error(details);</span>
<span class="fc" id="L236">			throw new OSException(details);</span>
<span class="fc" id="L237">		}</span>

<span class="fc" id="L239">		return plaintext;</span>
	}

	/**
	 * @param partialIV partial IV to expand
	 * @return partial IV as byte array length of int
	 * 
	 * @throws OSException if the partial IV is longer than length of int
	 */
	private static byte[] expandToIntSize(byte[] partialIV) throws OSException {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">		if (partialIV.length &gt; INTEGER_BYTES) {</span>
<span class="nc" id="L250">			LOGGER.error(&quot;The partial IV is: {} long, {} was expected&quot;, partialIV.length, INTEGER_BYTES);</span>
<span class="nc" id="L251">			throw new OSException(&quot;Partial IV too long&quot;);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">		} else if (partialIV.length == INTEGER_BYTES) {</span>
<span class="fc" id="L253">			return partialIV;</span>
		}
<span class="fc" id="L255">		byte[] ret = new byte[INTEGER_BYTES];</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">		for (int i = 0; i &lt; partialIV.length; i++) {</span>
<span class="fc" id="L257">			ret[INTEGER_BYTES - partialIV.length + i] = partialIV[i];</span>
		}
<span class="fc" id="L259">		return ret;</span>

	}

	/**
	 * @param protectedData the protected data to decrypt
	 * @return the COSE structure
	 */
	protected static Encrypt0Message prepareCOSEStructure(byte[] protectedData) {
<span class="nc" id="L268">		Encrypt0Message enc = new Encrypt0Message(false, true);</span>
		try {
<span class="nc" id="L270">			enc.DecodeFromCBORObject(CBORObject.DecodeFromBytes(protectedData));</span>
<span class="nc" id="L271">		} catch (CoseException e) {</span>
<span class="nc" id="L272">			e.printStackTrace();</span>
<span class="nc" id="L273">		}</span>
<span class="nc" id="L274">		return enc;</span>
	}

	/**
	 * Decompress the message.
	 * 
	 * @param cipherText the encrypted data
	 * @param message the received message
	 * @return the Encrypt0Message
	 * @throws OSException if OSCORE option fails to decode
	 */
	protected static Encrypt0Message decompression(byte[] cipherText, Message message) throws OSException {
<span class="fc" id="L286">		Encrypt0Message enc = new Encrypt0Message(false, true);</span>

		//Added try-catch for general Exception. The array manipulation can cause exceptions.
		try {
<span class="fc" id="L290">			decodeObjectSecurity(message, enc);</span>
<span class="nc" id="L291">		} catch (OSException e) {</span>
<span class="nc" id="L292">			LOGGER.error(e.getMessage());</span>
<span class="nc" id="L293">			throw e;</span>
<span class="nc" id="L294">		} catch (Exception e) {</span>
<span class="nc" id="L295">			LOGGER.error(&quot;Failed to decode object security option.&quot;);</span>
<span class="nc" id="L296">			throw new OSException(&quot;Failed to decode object security option.&quot;);</span>
<span class="fc" id="L297">		}</span>

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (cipherText != null)</span>
<span class="fc" id="L300">			enc.setEncryptedContent(cipherText);</span>

<span class="fc" id="L302">		return enc;</span>
	}

	/**
	 * Decodes and checks the Object-Security value.
	 * 
	 * @param message the received message
	 * @param enc the Encrypt0Message object
	 * @throws OSException if OSCORE option fails to decode
	 */
	private static void decodeObjectSecurity(Message message, Encrypt0Message enc) throws OSException {

<span class="fc" id="L314">		OscoreOptionDecoder optionDecoder = new OscoreOptionDecoder(message.getOptions().getOscore());</span>

<span class="fc" id="L316">		int n = optionDecoder.getN();</span>
<span class="fc" id="L317">		int k = optionDecoder.getK();</span>
<span class="fc" id="L318">		int h = optionDecoder.getH();</span>

<span class="fc" id="L320">		byte[] partialIV = optionDecoder.getPartialIV();</span>
<span class="fc" id="L321">		byte[] kid = optionDecoder.getKid();</span>
<span class="fc" id="L322">		byte[] kidContext = optionDecoder.getIdContext();</span>

		// Check Partial IV
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">		if (n &gt; 0 &amp;&amp; partialIV == null) {</span>
<span class="nc" id="L326">			LOGGER.error(&quot;Partial_IV is missing from message when it is expected.&quot;);</span>
<span class="nc" id="L327">			throw new OSException(ErrorDescriptions.FAILED_TO_DECODE_COSE);</span>
		}

		// Check KID Context
<span class="pc bpc" id="L331" title="1 of 4 branches missed.">		if (h != 0 &amp;&amp; kidContext == null) {</span>
<span class="nc" id="L332">			LOGGER.error(&quot;Kid context is missing from message when it is expected.&quot;);</span>
<span class="nc" id="L333">			throw new OSException(ErrorDescriptions.FAILED_TO_DECODE_COSE);</span>
		}

		// Check KID
<span class="pc bpc" id="L337" title="3 of 6 branches missed.">		if (k != 0 &amp;&amp; kid == null &amp;&amp; message instanceof Request) {</span>
<span class="nc" id="L338">			LOGGER.error(&quot;Kid is missing from message when it is expected.&quot;);</span>
<span class="nc" id="L339">			throw new OSException(ErrorDescriptions.FAILED_TO_DECODE_COSE);</span>
		}

		// Adding parsed data to Encrypt0Message object
		try {
<span class="fc bfc" id="L344" title="All 2 branches covered.">			if (partialIV != null) {</span>
<span class="fc" id="L345">				enc.addAttribute(HeaderKeys.PARTIAL_IV, CBORObject.FromObject(partialIV), Attribute.UNPROTECTED);</span>
			}
<span class="fc bfc" id="L347" title="All 2 branches covered.">			if (kid != null) {</span>
<span class="fc" id="L348">				enc.addAttribute(HeaderKeys.KID, CBORObject.FromObject(kid), Attribute.UNPROTECTED);</span>
			}

			// COSE Header parameter for KID Context defined as 10
			// https://www.iana.org/assignments/cose/cose.xhtml
<span class="fc" id="L353">			int kidContextKey = 10;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">			if (kidContext != null) {</span>
<span class="fc" id="L355">				enc.addAttribute(CBORObject.FromObject(kidContextKey), CBORObject.FromObject(kidContext),</span>
						Attribute.UNPROTECTED);
			}
<span class="nc" id="L358">		} catch (CoseException e) {</span>
<span class="nc" id="L359">			LOGGER.error(&quot;COSE processing of message failed.&quot;);</span>
<span class="nc" id="L360">			e.printStackTrace();</span>
<span class="fc" id="L361">		}</span>
<span class="fc" id="L362">	}</span>

	/**
	 * Replaces the message's options with a new OptionSet which doesn't contain
	 * any of the non-special E options as outer options
	 * 
	 * @param message the received message
	 */
	protected static void discardEOptions(Message message) {
<span class="fc" id="L371">		OptionSet newOptions = OptionJuggle.discardEOptions(message.getOptions());</span>
<span class="fc" id="L372">		message.setOptions(newOptions);</span>
<span class="fc" id="L373">	}</span>

	// TODO: Remove unneeded lines
	private static boolean checkSignature(Encrypt0Message enc, CounterSign1 sign) throws OSException {

<span class="fc" id="L378">		boolean countersignatureValid = false;</span>

		try {
<span class="fc" id="L381">			countersignatureValid = enc.validate(sign);</span>
<span class="nc" id="L382">		} catch (CoseException e) {</span>
<span class="nc" id="L383">			LOGGER.error(&quot;Countersignature checking procedure failed.&quot;);</span>
<span class="nc" id="L384">			e.printStackTrace();</span>
<span class="fc" id="L385">		}</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">		if (countersignatureValid == false) {</span>
<span class="fc" id="L388">			LOGGER.error(ErrorDescriptions.COUNTERSIGNATURE_CHECK_FAILED);</span>
<span class="fc" id="L389">			throw new OSException(ErrorDescriptions.COUNTERSIGNATURE_CHECK_FAILED);</span>
		}

<span class="fc" id="L392">		return countersignatureValid;</span>
	}

	// TODO: Remove unneeded lines
	private static CounterSign1 prepareCheckSignature(Encrypt0Message enc, OSCoreCtx ctx, byte[] aad, Message message) {

<span class="fc" id="L398">		CounterSign1 sign = null;</span>
<span class="fc" id="L399">		GroupRecipientCtx recipientCtx = (GroupRecipientCtx) ctx;</span>

		// First remove the countersignature from the payload
<span class="fc" id="L402">		byte[] full_payload = null;</span>
		try {
<span class="fc" id="L404">			full_payload = enc.getEncryptedContent();</span>

			// Set new truncated ciphertext
<span class="fc" id="L407">			int countersignatureLength = recipientCtx.getCountersignatureLen();</span>
<span class="fc" id="L408">			byte[] countersignatureBytes = Arrays.copyOfRange(full_payload,</span>
					full_payload.length - countersignatureLength, full_payload.length);
<span class="fc" id="L410">			byte[] ciphertext = Arrays.copyOfRange(full_payload, 0, full_payload.length - countersignatureLength);</span>
<span class="fc" id="L411">			enc.setEncryptedContent(ciphertext);</span>

			// Now actually prepare to check the countersignature
<span class="fc" id="L414">			OneKey recipientPublicKey = recipientCtx.getPublicKey();</span>
			// countersignatureBytes[3] = (byte) 0xff; // Corrupt
			// countersignature
<span class="fc" id="L417">			sign = new CounterSign1(countersignatureBytes);</span>
<span class="fc" id="L418">			sign.setKey(recipientPublicKey);</span>

<span class="fc" id="L420">			CBORObject signAlg = recipientCtx.getAlgSign().AsCBOR();</span>
<span class="fc" id="L421">			sign.addAttribute(HeaderKeys.Algorithm, signAlg, Attribute.DO_NOT_SEND);</span>
<span class="fc" id="L422">			byte[] signAad = aad;</span>

<span class="fc" id="L424">			sign.setExternal(signAad);</span>

<span class="fc" id="L426">			System.out.println(&quot;Checking signature for incoming &quot; + message.getClass().getSimpleName()</span>
<span class="fc" id="L427">					+ &quot; with sign AAD &quot; + Utils.toHexString(signAad));</span>
<span class="nc" id="L428">		} catch (Exception e) {</span>
<span class="nc" id="L429">			LOGGER.error(&quot;Countersignature verification procedure failed.&quot;);</span>
<span class="nc" id="L430">			e.printStackTrace();</span>
<span class="fc" id="L431">		}</span>

<span class="fc" id="L433">		return sign;</span>
	}

	private static void decryptSignature(Encrypt0Message enc, CounterSign1 sign, GroupRecipientCtx ctx,
			byte[] partialIV,
			byte[] kid, boolean isRequest) {

		// Derive the keystream
<span class="fc" id="L441">		String digest = &quot;&quot;;</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">		if (ctx.getKdf().toString().contains(&quot;SHA_256&quot;)) {</span>
<span class="fc" id="L443">			digest = &quot;SHA256&quot;;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">		} else if (ctx.getKdf().toString().contains(&quot;SHA_512&quot;)) {</span>
<span class="nc" id="L445">			digest = &quot;SHA512&quot;;</span>
		}

<span class="fc" id="L448">		CBORObject info = CBORObject.NewArray();</span>
<span class="fc" id="L449">		int keyLength = ctx.getCommonCtx().getCountersignatureLen();</span>

<span class="fc" id="L451">		info = CBORObject.NewArray();</span>
<span class="fc" id="L452">		info.Add(kid);</span>
<span class="fc" id="L453">		info.Add(ctx.getIdContext());</span>
<span class="fc" id="L454">		info.Add(isRequest);</span>
<span class="fc" id="L455">		info.Add(keyLength);</span>

<span class="fc" id="L457">		System.out.println(&quot;INFO ARRAY: &quot; + StringUtil.byteArray2Hex(info.EncodeToBytes()));</span>

<span class="fc" id="L459">		byte[] signatureEncryptionKey = ctx.getCommonCtx().getSignatureEncryptionKey();</span>
<span class="fc" id="L460">		byte[] keystream = null;</span>
		try {
<span class="fc" id="L462">			keystream = OSCoreCtx.deriveKey(signatureEncryptionKey, partialIV, keyLength, digest, info.EncodeToBytes());</span>

<span class="nc" id="L464">		} catch (CoseException e) {</span>
<span class="nc" id="L465">			System.err.println(e.getMessage());</span>
<span class="fc" id="L466">		}</span>

<span class="fc" id="L468">		System.out.println(&quot;===&quot;);</span>
<span class="fc" id="L469">		System.out.println(&quot;D Signature keystream: &quot; + Utils.toHexString(keystream));</span>
<span class="fc" id="L470">		System.out.println(&quot;D signatureEncryptionKey: &quot; + Utils.toHexString(signatureEncryptionKey));</span>
<span class="fc" id="L471">		System.out.println(&quot;D partialIV: &quot; + Utils.toHexString(partialIV));</span>
<span class="fc" id="L472">		System.out.println(&quot;D kid: &quot; + Utils.toHexString(kid));</span>
<span class="fc" id="L473">		System.out.println(&quot;D IdContext: &quot; + Utils.toHexString(ctx.getIdContext()));</span>
<span class="fc" id="L474">		System.out.println(&quot;D isRequest: &quot; + isRequest);</span>
<span class="fc" id="L475">		System.out.println(&quot;===&quot;);</span>

		// Now actually decrypt the signature
<span class="fc" id="L478">		byte[] full_payload = null;</span>
		try {
<span class="fc" id="L480">			full_payload = enc.getEncryptedContent();</span>
<span class="nc" id="L481">		} catch (CoseException e) {</span>
<span class="nc" id="L482">			LOGGER.error(&quot;Countersignature verification procedure failed.&quot;);</span>
<span class="nc" id="L483">			e.printStackTrace();</span>
<span class="fc" id="L484">		}</span>
<span class="fc" id="L485">		byte[] countersignBytes = Arrays.copyOfRange(full_payload, full_payload.length - keyLength,</span>
				full_payload.length);
<span class="fc" id="L487">		byte[] ciphertext = Arrays.copyOfRange(full_payload, 0, full_payload.length - keyLength);</span>

<span class="fc" id="L489">		byte[] decryptedCountersign = new byte[keystream.length];</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">		for (int i = 0; i &lt; keystream.length; i++) {</span>
<span class="fc" id="L491">			decryptedCountersign[i] = (byte) (countersignBytes[i] ^ keystream[i]);</span>
		}

<span class="fc" id="L494">		System.out.println(&quot;D Signature bytes: &quot; + Utils.toHexString(decryptedCountersign));</span>

		// Replace the signature in the Encrypt0 object
<span class="fc" id="L497">		enc.setEncryptedContent(Bytes.concatenate(ciphertext, decryptedCountersign));</span>
<span class="fc" id="L498">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>