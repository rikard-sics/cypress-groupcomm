<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HashMapCtxDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">HashMapCtxDB.java</span></div><h1>HashMapCtxDB.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.eclipse.californium.core.coap.CoAP;
import org.eclipse.californium.core.coap.CoAP.ResponseCode;
import org.eclipse.californium.core.coap.Token;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.oscore.group.GroupCtx;
import org.eclipse.californium.oscore.group.GroupSenderCtx;

/**
 * 
 * Implements the OSCoreCtxDB interface with HashMaps.
 *
 */
public class HashMapCtxDB implements OSCoreCtxDB {

	/**
	 * The logger
	 */
<span class="fc" id="L54">	private static final Logger LOGGER = LoggerFactory.getLogger(HashMapCtxDB.class);</span>

	// The outer HashMap has RID as key and the inner ID Context
	private HashMap&lt;ByteId, HashMap&lt;ByteId, OSCoreCtx&gt;&gt; contextMap;

	private HashMap&lt;Token, OSCoreCtx&gt; tokenMap;
	private HashMap&lt;String, OSCoreCtx&gt; uriMap;

	private ArrayList&lt;Token&gt; allTokens;

	/**
	 * Create the database
	 */
<span class="fc" id="L67">	public HashMapCtxDB() {</span>

<span class="fc" id="L69">		this.tokenMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L70">		this.contextMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L71">		this.uriMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L72">		this.allTokens = new ArrayList&lt;Token&gt;();</span>
<span class="fc" id="L73">	}</span>

	/**
	 * Retrieve context using RID and ID Context. If the provided ID Context is
	 * null a result will be returned if there is only one unique context for
	 * that RID.
	 */
	@Override
	public synchronized OSCoreCtx getContext(byte[] rid, byte[] IDContext) throws CoapOSException {
		// Do not allow a null RID
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">		if (rid == null) {</span>
<span class="nc" id="L84">			LOGGER.error(ErrorDescriptions.MISSING_KID);</span>
<span class="nc" id="L85">			throw new CoapOSException(ErrorDescriptions.MISSING_KID, ResponseCode.UNAUTHORIZED);</span>
		}

<span class="fc" id="L88">		HashMap&lt;ByteId, OSCoreCtx&gt; matchingRidMap = contextMap.get(new ByteId(rid));</span>

		// No matching RID found at all
<span class="fc bfc" id="L91" title="All 2 branches covered.">		if (matchingRidMap == null) {</span>
<span class="fc" id="L92">			return null;</span>
		}

		// If a RID was found get the specific context
<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (IDContext == null) {</span>
			// If retrieving using only RID, there must be only 1 match maximum
<span class="fc bfc" id="L98" title="All 2 branches covered.">			if (matchingRidMap.size() &gt; 1) {</span>
<span class="fc" id="L99">				throw new CoapOSException(ErrorDescriptions.CONTEXT_NOT_FOUND_IDCONTEXT, ResponseCode.UNAUTHORIZED);</span>
			} else {
				// If only one entry return it
<span class="fc" id="L102">				Map.Entry&lt;ByteId, OSCoreCtx&gt; first = matchingRidMap.entrySet().iterator().next();</span>
<span class="fc" id="L103">				return first.getValue();</span>
			}

		} else {
			// If retrieving using both RID and ID Context
<span class="fc" id="L108">			return matchingRidMap.get(new ByteId(IDContext));</span>
		}
	}

	/**
	 * Retrieve context using only RID when it is certain it is unique.
	 */
	@Override
	public synchronized OSCoreCtx getContext(byte[] rid) {
<span class="fc" id="L117">		HashMap&lt;ByteId, OSCoreCtx&gt; matchingRidMap = contextMap.get(new ByteId(rid));</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (matchingRidMap == null) {</span>
<span class="fc" id="L120">			return null;</span>
		}

<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (matchingRidMap.size() &gt; 1) {</span>
<span class="fc" id="L124">			throw new RuntimeException(&quot;Attempting to retrieve context with only non-unique RID.&quot;);</span>
		}

<span class="fc" id="L127">		Map.Entry&lt;ByteId, OSCoreCtx&gt; first = matchingRidMap.entrySet().iterator().next();</span>
<span class="fc" id="L128">		return first.getValue();</span>
	}

	@Override
	public synchronized OSCoreCtx getContextByToken(Token token) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">		if (token != null) {</span>
<span class="fc" id="L134">			return tokenMap.get(token);</span>
		} else {
<span class="nc" id="L136">			LOGGER.error(ErrorDescriptions.TOKEN_NULL);</span>
<span class="nc" id="L137">			throw new NullPointerException(ErrorDescriptions.TOKEN_NULL);</span>
		}
	}

	// TODO: Update
	@Override
	public synchronized OSCoreCtx getContextByIDContext(byte[] IDContext) {
<span class="fc bfc" id="L144" title="All 2 branches covered.">		for (Entry&lt;String, OSCoreCtx&gt; entry : uriMap.entrySet()) {</span>
<span class="fc" id="L145">			OSCoreCtx ctx = entry.getValue();</span>

<span class="pc bpc" id="L147" title="1 of 2 branches missed.">			if (Arrays.equals(IDContext, ctx.getIdContext())) {</span>
<span class="fc" id="L148">				return ctx;</span>
			}

<span class="nc" id="L151">		}</span>
<span class="fc" id="L152">		return null;</span>
	}

	@Override
	public synchronized OSCoreCtx getContext(String uri) throws OSException {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">		if (uri != null) {</span>
<span class="fc" id="L158">			return uriMap.get(normalizeServerUri(uri));</span>
		} else {
<span class="nc" id="L160">			LOGGER.error(ErrorDescriptions.STRING_NULL);</span>
<span class="nc" id="L161">			throw new NullPointerException(ErrorDescriptions.STRING_NULL);</span>
		}
	}

	@Override
	public synchronized void addContext(Token token, OSCoreCtx ctx) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if (token != null) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">			if (!tokenExist(token)) {</span>
<span class="fc" id="L169">				allTokens.add(token);</span>
			}
<span class="fc" id="L171">			tokenMap.put(token, ctx);</span>
		}
<span class="fc" id="L173">		addContext(ctx);</span>
<span class="fc" id="L174">	}</span>

	@Override
	public synchronized void addContext(String uri, OSCoreCtx ctx) throws OSException {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		if (uri != null) {</span>
<span class="fc" id="L179">			String normalizedUri = normalizeServerUri(uri);</span>
<span class="fc" id="L180">			uriMap.put(normalizedUri, ctx);</span>
<span class="fc" id="L181">			ctx.setUri(normalizedUri);</span>
		}
<span class="fc" id="L183">		addContext(ctx);</span>
<span class="fc" id="L184">	}</span>

	@Override
	public synchronized void addContext(String uri, GroupCtx ctx) throws OSException {
<span class="fc" id="L188">		ctx.addToDb(uri, this);</span>
<span class="fc" id="L189">	}</span>

	@Override
	public synchronized void addContext(OSCoreCtx ctx) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">		if (ctx != null) {</span>
			
			// Don't add Group OSCORE sender contexts as they have no RID
			// TODO: Is there some other way?
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (ctx instanceof GroupSenderCtx) {</span>
<span class="fc" id="L198">				return;</span>
			}

<span class="fc" id="L201">			ByteId rid = new ByteId(ctx.getRecipientId());</span>
<span class="fc" id="L202">			HashMap&lt;ByteId, OSCoreCtx&gt; ridMap = contextMap.get(rid);</span>

			// If there is no existing map for this RID, create it
<span class="fc bfc" id="L205" title="All 2 branches covered.">			if (ridMap == null) {</span>
<span class="fc" id="L206">				ridMap = new HashMap&lt;ByteId, OSCoreCtx&gt;();</span>
			}

			// Add the context to the RID map with ID context as key
<span class="fc" id="L210">			byte[] IDContext = ctx.getIdContext();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			if (IDContext == null) {</span>
<span class="fc" id="L212">				IDContext = Bytes.EMPTY;</span>
			}
<span class="fc" id="L214">			ridMap.put(new ByteId(IDContext), ctx);</span>

			// Put the updated map for this RID in the context map
<span class="fc" id="L217">			contextMap.put(rid, ridMap);</span>

<span class="fc" id="L219">		} else {</span>
<span class="nc" id="L220">			LOGGER.error(ErrorDescriptions.CONTEXT_NULL);</span>
<span class="nc" id="L221">			throw new NullPointerException(ErrorDescriptions.CONTEXT_NULL);</span>
		}
<span class="fc" id="L223">	}</span>

	@Override
	public synchronized void removeContext(OSCoreCtx ctx) {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">		if (ctx != null) {</span>

<span class="fc" id="L229">			ByteId rid = new ByteId(ctx.getRecipientId());</span>
<span class="fc" id="L230">			HashMap&lt;ByteId, OSCoreCtx&gt; ridMap = contextMap.get(rid);</span>

			// If there is no existing map for this RID return
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">			if (ridMap == null) {</span>
<span class="nc" id="L234">				return;</span>
			}

			// Remove the context from the RID map with ID context as key
<span class="fc" id="L238">			byte[] IDContext = ctx.getIdContext();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">			if (IDContext == null) {</span>
<span class="fc" id="L240">				IDContext = Bytes.EMPTY;</span>
			}
<span class="fc" id="L242">			ridMap.remove(new ByteId(IDContext));</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">			if (ridMap.isEmpty()) {</span>
				// If the RID map is now empty, remove it
<span class="fc" id="L246">				contextMap.remove(rid);</span>
			} else {

				// Put the updated map for this RID in the context map
<span class="fc" id="L250">				contextMap.put(rid, ridMap);</span>
			}

<span class="fc" id="L253">		} else {</span>
<span class="nc" id="L254">			LOGGER.error(ErrorDescriptions.CONTEXT_NULL);</span>
<span class="nc" id="L255">			throw new NullPointerException(ErrorDescriptions.CONTEXT_NULL);</span>
		}
<span class="fc" id="L257">	}</span>

	@Override
	public synchronized boolean tokenExist(Token token) {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">		if (token != null) {</span>
<span class="fc" id="L262">			return allTokens.contains(token);</span>
		} else {
<span class="nc" id="L264">			LOGGER.error(ErrorDescriptions.TOKEN_NULL);</span>
<span class="nc" id="L265">			throw new NullPointerException(ErrorDescriptions.TOKEN_NULL);</span>
		}
	}

	/**
	 * Normalize the request uri.
	 * 
	 * @param uri the request uri
	 * @return the normalized uri
	 *
	 * @throws OSException on failure to parse the URI
	 */
	private static String normalizeServerUri(String uri) throws OSException {
<span class="fc" id="L278">		String normalized = null;</span>
<span class="fc" id="L279">		int port = -1;</span>

		try {
<span class="fc" id="L282">			URI serverUri = new URI(uri);</span>
<span class="fc" id="L283">			port = serverUri.getPort();</span>
<span class="fc" id="L284">			normalized = serverUri.getHost();</span>
<span class="nc" id="L285">		} catch (URISyntaxException e) {</span>
			// workaround for openjdk bug JDK-8199396.
			// some characters are not supported for the ipv6 scope.
			try {
<span class="nc" id="L289">				String patternString = &quot;(%.*)]&quot;;</span>
<span class="nc" id="L290">				Pattern pattern = Pattern.compile(patternString);</span>

				//Save the original scope
<span class="nc" id="L293">				Matcher matcher = pattern.matcher(uri);</span>
<span class="nc" id="L294">				String originalScope = null;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">				if (matcher.find()) {</span>
<span class="nc" id="L296">					originalScope = matcher.group(1);</span>
				}

				//Remove unsupported characters in scope before getting the host component
<span class="nc" id="L300">				normalized = (new URI(uri.replaceAll(&quot;[-._~]&quot;, &quot;&quot;))).getHost();</span>

				//Find the modified new scope
<span class="nc" id="L303">				matcher = pattern.matcher(normalized);</span>
<span class="nc" id="L304">				String newScope = null;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">				if (matcher.find()) {</span>
<span class="nc" id="L306">					newScope = matcher.group(1);</span>
				}

				//Restore original scope for the IPv6 normalization
				//Otherwise getByName below will fail with &quot;no such interface&quot;
				//Since the scope is no longer matching the interface
<span class="nc bnc" id="L312" title="All 4 branches missed.">				if (newScope != null &amp;&amp; originalScope != null) {</span>
<span class="nc" id="L313">					normalized = normalized.replace(newScope, originalScope);</span>
				}

<span class="nc" id="L316">			} catch (URISyntaxException e2) {</span>
<span class="nc" id="L317">				LOGGER.error(&quot;Error in the request URI: {} message: {}&quot;, uri, e.getMessage());</span>
<span class="nc" id="L318">				throw new OSException(e.getMessage());</span>
<span class="nc" id="L319">			}</span>
<span class="fc" id="L320">		}</span>

		//Further normalization for IPv6 addresses
		//Normalization above can give different results depending on structure of IPv6 address
<span class="fc" id="L324">		InetAddress ipv6Addr = null;</span>
		try {
<span class="fc" id="L326">			ipv6Addr = InetAddress.getByName(normalized);</span>
<span class="nc" id="L327">		} catch (UnknownHostException e) {</span>
<span class="nc" id="L328">			LOGGER.error(&quot;Error finding host of request URI: {} message: {}&quot;, uri, e.getMessage());</span>
<span class="fc" id="L329">		}</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		if (ipv6Addr instanceof Inet6Address) {</span>
<span class="nc" id="L331">			normalized = &quot;[&quot; + ipv6Addr.getHostAddress() + &quot;]&quot;;</span>
		}

		// Consider port, if not default
<span class="fc bfc" id="L335" title="All 4 branches covered.">		if (port != -1 &amp;&amp; port != CoAP.DEFAULT_COAP_PORT) {</span>
<span class="fc" id="L336">			normalized = normalized + &quot;:&quot; + port;</span>
		}

<span class="fc" id="L339">		return normalized;</span>
	}

	/**
	 * Removes associations for this token, except for the generator
	 * 
	 * @param token the token to remove
	 */
	@Override
	public synchronized void removeToken(Token token) {
<span class="fc" id="L349">		tokenMap.remove(token);</span>
<span class="fc" id="L350">	}</span>

	/**
	 * Used mainly for test purpose, to purge the db of all contexts
	 */
	@Override
	public synchronized void purge() {
<span class="fc" id="L357">		contextMap.clear();</span>
<span class="fc" id="L358">		tokenMap.clear();</span>
<span class="fc" id="L359">		uriMap.clear();</span>
<span class="fc" id="L360">		allTokens = new ArrayList&lt;Token&gt;();</span>
<span class="fc" id="L361">	}</span>

	@Override
	public void printAllContexts() {
<span class="nc bnc" id="L365" title="All 2 branches missed.">		for (ByteId name : contextMap.keySet()) {</span>
<span class="nc" id="L366">			String key = name.toString();</span>
<span class="nc" id="L367">			String value = contextMap.get(name).toString();</span>
<span class="nc" id="L368">			System.out.println(key + &quot; &quot; + value);</span>
<span class="nc" id="L369">		}</span>
<span class="nc" id="L370">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>