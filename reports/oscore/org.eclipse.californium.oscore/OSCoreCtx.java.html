<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OSCoreCtx.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore</a> &gt; <span class="el_source">OSCoreCtx.java</span></div><h1>OSCoreCtx.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Joakim Brorsson
 *    Ludwig Seitz (RISE SICS)
 *    Tobias Andersson (RISE SICS)
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.util.Arrays;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.eclipse.californium.core.coap.CoAP.Code;
import org.eclipse.californium.core.config.CoapConfig;
import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.Attribute;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.Encrypt0Message;
import org.eclipse.californium.cose.EncryptCommon;
import org.eclipse.californium.cose.HeaderKeys;
import org.eclipse.californium.elements.config.Configuration;
import org.eclipse.californium.elements.config.UdpConfig;
import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.oscore.group.GroupRecipientCtx;
import org.eclipse.californium.oscore.group.GroupSenderCtx;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.upokecenter.cbor.CBORObject;

/**
 * 
 * Represents the Security Context and its parameters. At initiation derives the
 * keys and IVs. Also maintains replay window.
 *
 */
public class OSCoreCtx {

	static {
<span class="fc" id="L59">		CoapConfig.register();</span>
<span class="fc" id="L60">		UdpConfig.register();</span>
	}

	/**
	 * The logger
	 */
<span class="fc" id="L66">	private static final Logger LOGGER = LoggerFactory.getLogger(OSCoreCtx.class);</span>

	private static final byte ZERO = 0;
	private static final byte ONE = 1;

	private AlgorithmID common_alg;
	private byte[] common_master_secret;
	private byte[] common_master_salt;
	private byte[] common_iv;
	private byte[] context_id;

	protected byte[] sender_id;
	protected byte[] sender_key;
	protected int sender_seq;

	public byte[] recipient_id;
	public byte[] recipient_key;
	private int lowest_recipient_seq;
	private int recipient_replay_window_size;
	private int recipient_replay_window;

	private AlgorithmID kdf;

<span class="fc" id="L89">	private int seqMax = Integer.MAX_VALUE;</span>

	private int id_length;
	private int iv_length;
	private int key_length;

<span class="fc" id="L95">	private Code CoAPCode = null;</span>

	/**
	 * Include the context id in messages generated using this context. This is
	 * generally optional and can be controlled by the application.
	 *
	 * Default value is false.
	 */
	private boolean includeContextId;

	/**
	 * Generate a new partial IV for outgoing Response messages. If this
	 * variable is false the same nonce from the original request will be used.
	 * Otherwise a new partial IV will be generated by the sender and included
	 * in the Response. This affects the calculation of the nonce.
	 *
	 * See https://tools.ietf.org/html/rfc8613#section-5.2
	 *
	 * This variable will control the behaviour when sending Response messages
	 * with this context. Note that Observe notifications will always include a
	 * new partial IV.
	 *
	 * Default value is false.
	 */
	private boolean responsesIncludePartialIV;
	
	/**
	 * Indicates if this client/server shall support the context re-derivation
	 * procedure.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#appendix-B.2
	 */
	private boolean contextRederivationEnabled;

	/**
	 * When using outer block-wise with OSCORE a proxy can maliciously inject
	 * block fragments. To protect against this a message with size exceeding
	 * this parameter should never be sent without inner block-wise. Likewise
	 * when receiving a message using outer block-wise it should be discarded if
	 * the cumulated size exceeds this parameter.
	 * 
	 * See https://tools.ietf.org/html/rfc8613#section-4.1.3.4.2
	 */
	private int maxUnfragmentedSize;

	/**
	 * URI this Context is associated with if any.
	 *
	 * That is what URI it is associated and stored under in the HashMapCtxDB.
	 */
	private String uri;

	/**
	 * String versions of the context ID, sender ID and recipient ID.
	 *
	 * These are set when the context is created (rather than for every message)
	 * to be used later when adding information about the messages to the
	 * EndpointContext on sending or receiving a message.
	 */
	private final String contextIdString;
	private final String senderIdString;
	private final String recipientIdString;

	/**
	 * Key that is used during the context re-derivation process.
	 */
	private byte[] contextRederivationKey;

	/**
	 * Makes it possible to override the Context ID to include in messages.
	 * Typically this would be the Context ID this context was generated with
	 * but that is not the case for the context re-derivation procedure.
	 */
	private byte[] overrideContextId;

	/**
	 * Indicate which phase the context re-derivation procedure is in,
	 */
	private ContextRederivation.PHASE contextRederivationPhase;

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @throws OSException if the default KDF is not supported
	 */
	public OSCoreCtx(byte[] master_secret, boolean client) throws OSException {
<span class="fc" id="L184">		this(master_secret, client, Configuration.getStandard());</span>
<span class="fc" id="L185">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters with the
	 * minimal input.
	 * 
	 * @param master_secret the master secret
	 * @param client is this originally the client's context
	 * @param configuration configuration to be used by this context
	 * @throws OSException if the default KDF is not supported
	 * @since 3.0
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, Configuration configuration) throws OSException {
<span class="fc" id="L198">		this(master_secret, client, null, null, null, null, null, null, null,</span>
<span class="fc" id="L199">				configuration.get(CoapConfig.MAX_RESOURCE_BODY_SIZE));</span>
<span class="fc" id="L200">	}</span>

	public OSCoreCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, int maxUnfragmentedSize,
			boolean appB1Enabled) throws OSException {
<span class="nc" id="L205">		this(master_secret, client, alg, sender_id, recipient_id, kdf, replay_size, master_salt, contextId,</span>
				maxUnfragmentedSize);
<span class="nc" id="L207">		System.out.println(&quot;Appendix B.1 not supported currently&quot;);</span>
<span class="nc" id="L208">	}</span>

	/**
	 * Constructor. Generates the context from the base parameters.
	 * 
	 * @param master_secret the master secret
	 * @param alg the encryption algorithm as defined in COSE
	 * @param client is this originally the client's context
	 * @param sender_id the sender id or null for default
	 * @param recipient_id the recipient id or null for default
	 * @param kdf the COSE algorithm abbreviation of the kdf or null for the
	 *            default
	 * @param replay_size the replay window size or null for the default
	 * @param master_salt the optional master salt, can be null
	 * @param contextId the context id, can be null
	 * @param maxUnfragmentedSize maximum unfragmented size 
	 *
	 * @throws OSException if the KDF is not supported
	 * @since 3.0 (added parameter maxUnfragmentedSize)
	 */
	public OSCoreCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
<span class="fc" id="L229">			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, int maxUnfragmentedSize) throws OSException {</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">		if (alg == null) {</span>
<span class="fc" id="L232">			this.common_alg = AlgorithmID.AES_CCM_16_64_128;</span>
		} else {
<span class="fc" id="L234">			this.common_alg = alg;</span>
		}

<span class="fc" id="L237">		setLengths();</span>

<span class="fc" id="L239">		this.sender_seq = 0;</span>
<span class="fc" id="L240">		this.lowest_recipient_seq = 0;</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">		if (master_secret != null) {</span>
<span class="fc" id="L243">			this.common_master_secret = master_secret.clone();</span>
		} else {
<span class="fc" id="L245">			LOGGER.error(&quot;Input master secret is null&quot;);</span>
<span class="fc" id="L246">			throw new NullPointerException(&quot;Input master secret is null&quot;);</span>
		}
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">		if (sender_id == null || sender_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">			this.sender_id = createByteArray(client ? ZERO : ONE);</span>
		} else {
<span class="fc" id="L251">			this.sender_id = sender_id.clone();</span>
		}

<span class="pc bpc" id="L254" title="1 of 4 branches missed.">		if (recipient_id == null || recipient_id.length &gt; this.id_length) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">			this.recipient_id = createByteArray(client ? ONE : ZERO);</span>
		} else {
<span class="fc" id="L257">			this.recipient_id = recipient_id.clone();</span>
		}

<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (kdf == null) {</span>
<span class="fc" id="L261">			this.kdf = AlgorithmID.HKDF_HMAC_SHA_256;</span>
		} else {
<span class="fc" id="L263">			this.kdf = kdf;</span>
		}

<span class="fc bfc" id="L266" title="All 2 branches covered.">		if (replay_size == null) {</span>
<span class="fc" id="L267">			this.recipient_replay_window_size = 32;</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">		} else if (replay_size &gt; 32) {</span>
<span class="nc" id="L269">			LOGGER.warn(&quot;Maximum size of replay window is 32. Setting to 32.&quot;);</span>
<span class="nc" id="L270">			this.recipient_replay_window_size = 32;</span>
		} else {
<span class="fc" id="L272">			this.recipient_replay_window_size = replay_size.intValue();</span>
		}
<span class="fc" id="L274">		this.recipient_replay_window = 0;</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (master_salt == null) {</span>
			// Default value. Automatically initialized with 0-es.
<span class="fc" id="L278">			this.common_master_salt = new byte[this.kdf.getKeySize() / Byte.SIZE];</span>
		} else {
<span class="fc" id="L280">			this.common_master_salt = master_salt.clone();</span>
		}

<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (contextId != null) {</span>
<span class="fc" id="L284">			this.context_id = contextId.clone();</span>
		} else {
<span class="fc" id="L286">			this.context_id = null;</span>
		}

		// Set default values for these flags
		//They can be set by the application using their setters
<span class="fc" id="L291">		includeContextId = false;</span>
<span class="fc" id="L292">		responsesIncludePartialIV = false;</span>
<span class="fc" id="L293">		contextRederivationEnabled = false;</span>

		//Set string versions of sender ID, recipient ID and Context ID
<span class="fc" id="L296">		contextIdString = toHex(this.context_id);</span>
<span class="fc" id="L297">		senderIdString = toHex(this.sender_id);</span>
<span class="fc" id="L298">		recipientIdString = toHex(this.recipient_id);</span>

		//Initialize the URI associated with the context
		//It will be overwritten if this context is added to a HashMapCtxDB
<span class="fc" id="L302">		uri = &quot;&quot;;</span>

<span class="fc" id="L304">		overrideContextId = null;</span>
<span class="fc" id="L305">		contextRederivationPhase = ContextRederivation.PHASE.INACTIVE;</span>

		// Set default value of MAX_UNFRAGMENTED_SIZE
<span class="fc" id="L308">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>

		//Set digest value depending on HKDF
<span class="fc" id="L311">		String digest = null;</span>
<span class="pc bpc" id="L312" title="1 of 3 branches missed.">		switch (this.kdf) {</span>
		case HKDF_HMAC_SHA_256:
		case HMAC_SHA_256:
<span class="fc" id="L315">			digest = &quot;SHA256&quot;;</span>
<span class="fc" id="L316">			break;</span>
		case HKDF_HMAC_SHA_512:
		case HMAC_SHA_512:
<span class="fc" id="L319">			digest = &quot;SHA512&quot;;</span>
<span class="fc" id="L320">			break;</span>
		case HKDF_HMAC_AES_128:
		case HKDF_HMAC_AES_256:
		default:
<span class="nc" id="L324">			LOGGER.error(&quot;Requested HKDF algorithm is not supported: {}&quot;, this.kdf);</span>
<span class="nc" id="L325">			throw new OSException(&quot;HKDF algorithm not supported&quot;);</span>
		}

		// Derive sender_key
<span class="fc" id="L329">		CBORObject info = CBORObject.NewArray();</span>
<span class="fc" id="L330">		info.Add(this.sender_id);</span>
<span class="fc" id="L331">		info.Add(this.context_id);</span>
<span class="fc" id="L332">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L333">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L334">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L337">			this.sender_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L338">					info.EncodeToBytes());</span>
<span class="nc" id="L339">		} catch (CoseException e) {</span>
<span class="nc" id="L340">			String details = e.getMessage();</span>
<span class="nc" id="L341">			LOGGER.error(details);</span>
<span class="nc" id="L342">			throw new OSException(details);</span>
<span class="fc" id="L343">		}</span>

		// Derive recipient_key
<span class="fc" id="L346">		info = CBORObject.NewArray();</span>
<span class="fc" id="L347">		info.Add(this.recipient_id);</span>
<span class="fc" id="L348">		info.Add(this.context_id);</span>
<span class="fc" id="L349">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L350">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L351">		info.Add(this.key_length);</span>

		try {
<span class="fc" id="L354">			this.recipient_key = deriveKey(this.common_master_secret, this.common_master_salt, this.key_length, digest,</span>
<span class="fc" id="L355">					info.EncodeToBytes());</span>
<span class="nc" id="L356">		} catch (CoseException e) {</span>
<span class="nc" id="L357">			String details = e.getMessage();</span>
<span class="nc" id="L358">			LOGGER.error(details);</span>
<span class="nc" id="L359">			throw new OSException(details);</span>
<span class="fc" id="L360">		}</span>

		// Derive common_iv
<span class="fc" id="L363">		info = CBORObject.NewArray();</span>
<span class="fc" id="L364">		info.Add(Bytes.EMPTY);</span>
<span class="fc" id="L365">		info.Add(this.context_id);</span>
<span class="fc" id="L366">		info.Add(this.common_alg.AsCBOR());</span>
<span class="fc" id="L367">		info.Add(CBORObject.FromObject(&quot;IV&quot;));</span>
<span class="fc" id="L368">		info.Add(this.iv_length);</span>

		try {
<span class="fc" id="L371">			this.common_iv = deriveKey(this.common_master_secret, this.common_master_salt, this.iv_length, digest,</span>
<span class="fc" id="L372">					info.EncodeToBytes());</span>
<span class="nc" id="L373">		} catch (CoseException e) {</span>
<span class="nc" id="L374">			String details = e.getMessage();</span>
<span class="nc" id="L375">			LOGGER.error(details);</span>
<span class="nc" id="L376">			throw new OSException(details);</span>
<span class="fc" id="L377">		}</span>

		// Initialize cipher object
<span class="fc" id="L380">		initializeCipher(common_alg);</span>

<span class="fc" id="L382">	}</span>

	/**
	 * Overrides hasCode to provide a functional implementation for this class.
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L389">		return 31 * Arrays.hashCode(sender_id) + Arrays.hashCode(recipient_id);</span>
	}

	/**
	 * Overrides equals to provide a functional implementation for this class.
	 */
	@Override
	public boolean equals(Object o) {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		if (!(o instanceof OSCoreCtx)) {</span>
<span class="nc" id="L398">			return false;</span>
		}
<span class="fc" id="L400">		OSCoreCtx other = (OSCoreCtx) o;</span>

<span class="pc bpc" id="L402" title="2 of 4 branches missed.">		return Arrays.equals(other.sender_id, sender_id) &amp;&amp; Arrays.equals(other.recipient_id, recipient_id);</span>
	}

	/**
	 * @return the sender key
	 */
	public byte[] getSenderKey() {
<span class="fc" id="L409">		return sender_key;</span>
	}

	/**
	 * @return the recipient key
	 */
	public byte[] getRecipientKey() {
<span class="fc" id="L416">		return recipient_key;</span>
	}

	/**
	 * @return the encryption algorithm
	 */
	public AlgorithmID getAlg() {
<span class="fc" id="L423">		return this.common_alg;</span>
	}

	/**
	 * @return the sender sequence number
	 */
	public synchronized int getSenderSeq() {
<span class="fc" id="L430">		return sender_seq;</span>
	}

	/**
	 * @return the lowest recipient sequence number in current replay window
	 */
	public synchronized int getLowestRecipientSeq() {
<span class="fc" id="L437">		return lowest_recipient_seq;</span>
	}

	/**
	 * @return the sender's identifier
	 */
	public byte[] getSenderId() {
<span class="fc" id="L444">		return sender_id;</span>
	}

	/**
	 * @return the repipient's identifier
	 */
	public byte[] getRecipientId() {
<span class="fc" id="L451">		return recipient_id;</span>
	}

	/**
	 * @return the common_iv
	 */
	public byte[] getCommonIV() {
<span class="fc" id="L458">		return common_iv;</span>
	}

	/**
	 * @param common_iv the Common IV to set
	 */
	public void setCommonIV(byte[] common_iv) {
<span class="fc" id="L465">		this.common_iv = common_iv;</span>
<span class="fc" id="L466">	}</span>

	/**
	 * @return the set length of IV:s
	 */
	public int getIVLength() {
<span class="fc" id="L472">		return iv_length;</span>
	}

	/**
	 * @return size of recipient replay window
	 */
	public int getRecipientReplaySize() {
<span class="fc" id="L479">		return recipient_replay_window_size;</span>
	}

	/**
	 * @return recipient replay window
	 */
	public int getRecipientReplayWindow() {
<span class="fc" id="L486">		return recipient_replay_window;</span>
	}

	public byte[] getMasterSecret() {
<span class="fc" id="L490">		return common_master_secret;</span>
	}

	public byte[] getSalt() {
<span class="fc" id="L494">		return common_master_salt;</span>
	}

	public AlgorithmID getKdf() {
<span class="fc" id="L498">		return kdf;</span>
	}
	
	/**
	 * Enables getting the ID Context
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getIdContext() {
<span class="fc" id="L507">		return context_id;</span>
	}

	/**
	 * Enables getting the ID Context to put in an outgoing message.
	 *
	 * Typically this will be the Context ID this context was generated with but
	 * it may be different when performing the context re-derivation procedure.
	 * 
	 * @return Byte array with ID Context
	 */
	public byte[] getMessageIdContext() {
<span class="fc bfc" id="L519" title="All 2 branches covered.">		if (overrideContextId != null) {</span>
<span class="fc" id="L520">			return overrideContextId;</span>
		} else {
<span class="fc" id="L522">			return context_id;</span>
		}
	}

	/**
	 * Get the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 *
	 * @return the includeContextId
	 */
	public boolean getIncludeContextId() {
<span class="fc" id="L533">		return includeContextId;</span>
	}

	/**
	 * Set the flag controlling whether or not to include the Context ID in
	 * messages generated using this context.
	 * 
	 * Note that this flag should never be set to true in a context without a Context ID set.
	 *
	 * @param includeContextId the includeContextId to set
	 *
	 * @throws IllegalStateException if a Context ID has not been set for this context
	 */
	public void setIncludeContextId(boolean includeContextId) {
<span class="pc bpc" id="L547" title="3 of 4 branches missed.">		if (context_id == null &amp;&amp; overrideContextId == null) {</span>
<span class="nc" id="L548">			LOGGER.error(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
<span class="nc" id="L549">			throw new IllegalStateException(&quot;Context ID cannot be included for a context without one set.&quot;);</span>
		}
		
		// If Context ID is not to be included clear the overriding Context ID
		// possibly set to be included in messages
<span class="fc bfc" id="L554" title="All 2 branches covered.">		if (!includeContextId) {</span>
<span class="fc" id="L555">			this.overrideContextId = null;</span>
		}

<span class="fc" id="L558">		this.includeContextId = includeContextId;</span>
<span class="fc" id="L559">	}</span>

	/**
	 * Indicate as a parameter exactly what Context ID should be included.
	 * Normally that would be the Context ID this context was generated with but
	 * that is not the case for the context re-derivation procedure.
	 * 
	 * @param overrideContextId the Context ID to include in messages
	 */
	public void setIncludeContextId(byte[] overrideContextId) {
<span class="fc" id="L569">		this.overrideContextId = overrideContextId.clone();</span>
<span class="fc" id="L570">		this.setIncludeContextId(true);</span>
<span class="fc" id="L571">	}</span>

	/**
	 * Get the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @return the responsesIncludePartialIV
	 */
	public boolean getResponsesIncludePartialIV() {
<span class="fc" id="L580">		return responsesIncludePartialIV;</span>
	}

	/**
	 * Set the flag controlling whether or not to generate a new partial IV for
	 * outgoing Response messages using this context.
	 * 
	 * @param responsesIncludePartialIV the responsesIncludePartialIV to set
	 */
	public void setResponsesIncludePartialIV(boolean responsesIncludePartialIV) {
<span class="fc" id="L590">		this.responsesIncludePartialIV = responsesIncludePartialIV;</span>
<span class="fc" id="L591">	}</span>

	/**
	 * Get the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @return the contextRederivationEnabled
	 */
	public boolean getContextRederivationEnabled() {
<span class="fc" id="L600">		return contextRederivationEnabled;</span>
	}

	/**
	 * Set the flag controlling whether or not this context supports the context
	 * re-derivation procedure.
	 * 
	 * @param contextRederivationEnabled the contextRederivationEnabled to set
	 */
	public void setContextRederivationEnabled(boolean contextRederivationEnabled) {
<span class="fc" id="L610">		this.contextRederivationEnabled = contextRederivationEnabled;</span>
<span class="fc" id="L611">	}</span>

	/**
	 * Gets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @return the current value of MAX_UNFRAGMENTED_SIZE
	 */
	public int getMaxUnfragmentedSize() {
<span class="fc" id="L620">		return maxUnfragmentedSize;</span>
	}

	/**
	 * Sets the current value of the MAX_UNFRAGMENTED_SIZE parameter. It is used
	 * to prevent malicious behaviour by a proxy when using block-wise.
	 * 
	 * @param maxUnfragmentedSize the desired value of MAX_UNFRAGMENTED_SIZE
	 */
	public void setMaxUnfragmentedSize(int maxUnfragmentedSize) {
<span class="fc" id="L630">		this.maxUnfragmentedSize = maxUnfragmentedSize;</span>
<span class="fc" id="L631">	}</span>

	/**
	 * Get a string representation of the context ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the contextIdString
	 */
	public String getContextIdString() {
<span class="fc" id="L640">		return contextIdString;</span>
	}

	/**
	 * Get a string representation of the sender ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the senderIdString
	 */
	public String getSenderIdString() {
<span class="fc" id="L650">		return senderIdString;</span>
	}

	/**
	 * Get a string representation of the recipient ID. (A string showing the
	 * hexadecimal bytes.)
	 *
	 * @return the recipientIdString
	 */
	public String getRecipientIdString() {
<span class="fc" id="L660">		return recipientIdString;</span>
	}

	/**
	 * @param seq the sender sequence number to set
	 */
	public synchronized void setSenderSeq(int seq) {
<span class="fc" id="L667">		sender_seq = seq;</span>
<span class="fc" id="L668">	}</span>

	/**
	 * @param seq the recipient sequence number to set
	 * @since 3.11 (adjust visibility to public)
	 */
	public synchronized void setRecipientSeq(int seq) {
<span class="fc" id="L675">		lowest_recipient_seq = seq;</span>
<span class="fc" id="L676">	}</span>

	/**
	 * @param window the recipient replay window to set
	 * @since 3.11
	 */
	public synchronized void setRecipientReplayWindow(int window) {
<span class="nc" id="L683">		recipient_replay_window = window;</span>
<span class="nc" id="L684">	}</span>

	/**
	 * Enables setting the sender key
	 * 
	 * @param senderKey the sender key to set
	 */
	public void setSenderKey(byte[] senderKey) {
<span class="fc" id="L692">		this.sender_key = senderKey.clone();</span>
<span class="fc" id="L693">	}</span>
	
	/**
	 * Enables setting the recipient key
	 * 
	 * @param recipientKey the recipient key to set
	 */
	public void setRecipientKey(byte[] recipientKey) {
<span class="fc" id="L701">		this.recipient_key = recipientKey.clone();</span>
<span class="fc" id="L702">	}</span>
	
	/**
	 * Set the maximum sequence number.
	 * 
	 * @param seqMax the maximum sequence number.
	 */
	public void setSeqMax(int seqMax) {
<span class="fc" id="L710">		this.seqMax = seqMax;</span>
<span class="fc" id="L711">	}</span>

	/**
	 * Sets the valid lengths, in bytes, of constrained variables(ids, IVs and
	 * keys).
	 * 
	 * @throws RuntimeException if not this.common_alg has been initiated
	 */
	private void setLengths() {
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">		if (common_alg != null) {</span>

<span class="fc" id="L722">			iv_length = EncryptCommon.getIvLength(common_alg);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">			if (iv_length &gt; 0) {</span>
<span class="fc" id="L724">				id_length = iv_length - 6; // RFC section 5.2</span>
<span class="fc" id="L725">				key_length = common_alg.getKeySize() / 8;</span>

			} else {
<span class="fc" id="L728">				LOGGER.error(&quot;Requested AEAD algorithm is not supported: {}&quot;, common_alg);</span>
<span class="fc" id="L729">				throw new RuntimeException(&quot;AEAD algorithm not supported&quot;);</span>
			}

		} else {
<span class="nc" id="L733">			LOGGER.error(&quot;Common_alg has not yet been initiated.&quot;);</span>
<span class="nc" id="L734">			throw new RuntimeException(&quot;Common_alg has not yet been initiated.&quot;);</span>
		}
<span class="fc" id="L736">	}</span>

	/**
	 * @return the URI this context is associated with if any.
	 */
	public String getUri() {
<span class="fc" id="L742">		return uri;</span>
	}

	/**
	 * Sets the URI this context is associated with.
	 * (The URI it is saved under in the HashMapCtxDB.)
	 *
	 * This will be set when added to the HashMapCtxDB.
	 *
	 * @param uri the URI this OSCORE context is associated with
	 */
	protected void setUri(String uri) {
<span class="fc" id="L754">		this.uri = uri;</span>
<span class="fc" id="L755">	}</span>

	/**
	 * Get the context re-derivation key.
	 * 
	 * @return the context re-derivation key
	 */
	protected byte[] getContextRederivationKey() {
<span class="fc" id="L763">		return contextRederivationKey;</span>
	}

	/**
	 * Sets the context re-derivation key.
	 * 
	 * @param contextRederivationKey the context re-derivation key to set
	 */
	protected void setContextRederivationKey(byte[] contextRederivationKey) {
<span class="fc" id="L772">		this.contextRederivationKey = contextRederivationKey;</span>
<span class="fc" id="L773">	}</span>

	/**
	 * Check the phase of the context re-derivation process.
	 * 
	 * @return the contextRederivationOngoing
	 */
	public ContextRederivation.PHASE getContextRederivationPhase() {
<span class="fc" id="L781">		return contextRederivationPhase;</span>
	}

	/**
	 * Set the phase of the context re-derivation process.
	 * 
	 * @param contextRederivationPhase the contextRederivationPhase to set
	 */
	public void setContextRederivationPhase(ContextRederivation.PHASE contextRederivationPhase) {
<span class="fc" id="L790">		this.contextRederivationPhase = contextRederivationPhase;</span>
<span class="fc" id="L791">	}</span>

	/**
	 * Increase the sender's sequence number by one
	 *
	 * @throws OSException if the sequence number wraps
	 */
	public synchronized void increaseSenderSeq() throws OSException {
<span class="fc bfc" id="L799" title="All 2 branches covered.">		if (sender_seq &gt;= seqMax) {</span>
<span class="fc" id="L800">			LOGGER.error(&quot;Sequence number wrapped, get a new OSCore context&quot;);</span>
<span class="fc" id="L801">			throw new OSException(&quot;Sequence number wrapped&quot;);</span>
		}
<span class="fc" id="L803">		sender_seq++;</span>
<span class="fc" id="L804">	}</span>

	// For interop testing
<span class="fc" id="L807">	public static boolean DISABLE_REPLAY_CHECKS = false;</span>

	/**
	 * Checks and validates the sequence number for incoming messages.
	 * 
	 * @param seq the incoming sequence number
	 * 
	 * @throws OSException if the sequence number wraps or if it is a replay
	 */
	public synchronized void checkIncomingSeq(int seq) throws OSException {

<span class="fc bfc" id="L818" title="All 2 branches covered.">		if (seq &gt;= seqMax) {</span>
<span class="fc" id="L819">			LOGGER.error(&quot;Sequence number wrapped, get new OSCore context&quot;);</span>
<span class="fc" id="L820">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

<span class="fc bfc" id="L823" title="All 2 branches covered.">		if (seq &lt; lowest_recipient_seq) {</span>
<span class="fc" id="L824">			LOGGER.error(&quot;Message too old&quot;);</span>
<span class="fc" id="L825">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

		// Check validity
<span class="fc" id="L829">		boolean valid = false;</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">		if (seq &gt;= lowest_recipient_seq + recipient_replay_window_size) {</span>
<span class="fc" id="L831">			valid = true;</span>
		} else {
<span class="fc bfc" id="L833" title="All 2 branches covered.">			valid = ((recipient_replay_window &gt;&gt; (seq - lowest_recipient_seq)) &amp; 1) == 0;</span>
		}
<span class="pc bpc" id="L835" title="1 of 4 branches missed.">		if (!valid &amp;&amp; DISABLE_REPLAY_CHECKS == false) {</span>
<span class="fc" id="L836">			LOGGER.error(&quot;Replayed message detected&quot;);</span>
<span class="fc" id="L837">			throw new OSException(ErrorDescriptions.REPLAY_DETECT);</span>
		}

		// Update window
<span class="fc" id="L841">		int shift = seq - (lowest_recipient_seq + recipient_replay_window_size - 1);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">		if (shift &gt; 0) {</span>
<span class="fc" id="L843">			recipient_replay_window &gt;&gt;= shift;</span>
<span class="fc" id="L844">			lowest_recipient_seq += shift;</span>
		}
<span class="fc" id="L846">		recipient_replay_window |= 1 &lt;&lt; (seq - lowest_recipient_seq);</span>
<span class="fc" id="L847">	}</span>

	public static byte[] deriveKey(byte[] secret, byte[] salt, int cbitKey, String digest, byte[] rgbContext)
			throws CoseException {

<span class="fc" id="L852">		final String HMAC_ALG_NAME = &quot;Hmac&quot; + digest;</span>

		try {
<span class="fc" id="L855">			Mac hmac = Mac.getInstance(HMAC_ALG_NAME);</span>
<span class="fc" id="L856">			int hashLen = hmac.getMacLength();</span>

			// Perform extract
<span class="fc" id="L859">			hmac.init(new SecretKeySpec(salt, HMAC_ALG_NAME));</span>
<span class="fc" id="L860">			byte[] rgbExtract = hmac.doFinal(secret);</span>

			// Perform expand
<span class="fc" id="L863">			hmac.init(new SecretKeySpec(rgbExtract, HMAC_ALG_NAME));</span>
<span class="fc" id="L864">			int c = (cbitKey / hashLen) + 1;</span>
<span class="fc" id="L865">			byte[] rgbOut = new byte[cbitKey];</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">			int maxLen = (hashLen * c &gt; cbitKey) ? hashLen * c : cbitKey;</span>
<span class="fc" id="L867">			byte[] T = new byte[maxLen];</span>
<span class="fc" id="L868">			byte[] last = new byte[0];</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">			for (int i = 0; i &lt; c; i++) {</span>
<span class="fc" id="L870">				hmac.reset();</span>
<span class="fc" id="L871">				hmac.update(last);</span>
<span class="fc" id="L872">				hmac.update(rgbContext);</span>
<span class="fc" id="L873">				hmac.update((byte) (i + 1));</span>
<span class="fc" id="L874">				last = hmac.doFinal();</span>
<span class="fc" id="L875">				System.arraycopy(last, 0, T, i * hashLen, hashLen);</span>
			}
<span class="fc" id="L877">			System.arraycopy(T, 0, rgbOut, 0, cbitKey);</span>
<span class="fc" id="L878">			return rgbOut;</span>
<span class="nc" id="L879">		} catch (NoSuchAlgorithmException | InvalidKeyException ex) {</span>
<span class="nc" id="L880">			throw new CoseException(&quot;Algorithm not supported&quot;, ex);</span>
<span class="nc" id="L881">		} catch (Exception ex) {</span>
<span class="nc" id="L882">			throw new CoseException(&quot;Derivation failure&quot;, ex);</span>
		}
	}

	/**
	 * Converts a byte array to a hexadecimal string representation.
	 *
	 * @param bytes the byte array to convert
	 * @return the string representation
	 */
	private String toHex(byte[] bytes) {
<span class="fc bfc" id="L893" title="All 4 branches covered.">		if(bytes == null || bytes.length == 0) {</span>
<span class="fc" id="L894">			return &quot;&quot;;</span>
		} else {
<span class="fc" id="L896">			return StringUtil.byteArray2Hex(bytes);</span>
		}
	}

	/**
	 * Returns this CoAPCode.
	 * 
	 * @return the coap code
	 */
	public Code getCoAPCode() {
<span class="fc" id="L906">		return CoAPCode;</span>
	}

	/**
	 * Sets this CoAPCode to CoAPCode
	 * 
	 * @param coapCode coap code.
	 */
	public void setCoAPCode(Code coapCode) {
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">		if (coapCode != null) {</span>
<span class="fc" id="L916">			this.CoAPCode = coapCode;</span>
		}
<span class="fc" id="L918">	}</span>

	/**
	 * Initializes the cipher object by calling encrypt on an Encrypt0Message
	 * object created with dummy data. Doing this at creation of the OSCORE
	 * context reduces the latency for the first request since it would
	 * otherwise happen then.
	 * 
	 * @param alg the encryption algorithm used
	 */
	private void initializeCipher(AlgorithmID alg) {

<span class="pc bpc" id="L930" title="2 of 4 branches missed.">		if ((alg == AlgorithmID.CHACHA20_POLY1305 || alg == AlgorithmID.CHACHA20)</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">				&amp;&amp; Security.getProvider(&quot;BC&quot;) == null) {</span>
<span class="nc" id="L932">			Security.addProvider(new BouncyCastleProvider());</span>
		}

<span class="fc" id="L935">		byte[] key = Arrays.copyOf(sender_id, key_length);</span>
<span class="fc" id="L936">		byte[] iv = Arrays.copyOf(recipient_id, iv_length);</span>
<span class="fc" id="L937">		byte[] aad = new byte[10];</span>

<span class="fc" id="L939">		Encrypt0Message enc = new Encrypt0Message(false, true);</span>
<span class="fc" id="L940">		enc.SetContent(&quot;init&quot;);</span>
<span class="fc" id="L941">		enc.setExternal(aad);</span>

		try {
<span class="fc" id="L944">			enc.addAttribute(HeaderKeys.IV, CBORObject.FromObject(iv), Attribute.DO_NOT_SEND);</span>
<span class="fc" id="L945">			enc.addAttribute(HeaderKeys.Algorithm, alg.AsCBOR(), Attribute.DO_NOT_SEND);</span>
<span class="fc" id="L946">			enc.encrypt(key);</span>
<span class="nc" id="L947">		} catch (IllegalStateException | CoseException e) {</span>
<span class="nc" id="L948">			LOGGER.error(&quot;Failed to initialize cipher for algorithm {}. Ensure that the JCE supports it.&quot;, alg);</span>
<span class="nc" id="L949">			throw new RuntimeException(&quot;Failed to initialize cipher&quot;);</span>
<span class="fc" id="L950">		}</span>
<span class="fc" id="L951">	}</span>

	/**
	 * Create byte array from values.
	 * 
	 * @param values bytes for byte array
	 * @return initialized byte array
	 */
	private static byte[] createByteArray(byte... values) {
<span class="fc" id="L960">		return values;</span>
	}

	/**
	 * Holds nonce to hand over between different Security Contexts during
	 * execution of Appendix B.2
	 */
	private byte[] nonceHandover;

	/**
	 * Set nonce to hand over during execution of Appendix B.2
	 * 
	 * @param nonce the nonce value to hand over
	 */
	protected void setNonceHandover(byte[] nonce) {
<span class="fc" id="L975">		this.nonceHandover = nonce;</span>
<span class="fc" id="L976">	}</span>

	/**
	 * Get nonce for hand over during execution of Appendix B.2
	 * 
	 * @return the retrieved nonce value
	 */
	protected byte[] getNonceHandover() {
<span class="fc" id="L984">		return nonceHandover;</span>
	}

	/**
	 * Provides a method to check if this context is used for Group OSCORE.
	 * 
	 * @return if this is a group (Group OSCORE) context
	 */
	public boolean isGroupContext() {
<span class="fc bfc" id="L993" title="All 4 branches covered.">		return this instanceof GroupSenderCtx || this instanceof GroupRecipientCtx;</span>
	}

	// TODO: Remove?
	protected GroupSenderCtx getSenderCtx() {
<span class="nc" id="L998">		return null;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>