<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupSenderCtx.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cf-OSCORE</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.californium.oscore.group</a> &gt; <span class="el_source">GroupSenderCtx.java</span></div><h1>GroupSenderCtx.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 RISE SICS and others.
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 * 
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v20.html
 * and the Eclipse Distribution License is available at
 *    http://www.eclipse.org/org/documents/edl-v10.html.
 * 
 * Contributors:
 *    Rikard HÃ¶glund (RISE SICS)
 *    
 ******************************************************************************/
package org.eclipse.californium.oscore.group;

import java.util.HashMap;
import java.util.Map.Entry;

import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.OneKey;

import org.eclipse.californium.elements.util.Bytes;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.oscore.ByteId;
import org.eclipse.californium.oscore.OSCoreCtx;
import org.eclipse.californium.oscore.OSException;

import com.upokecenter.cbor.CBORObject;

/**
 * Class implementing a Group OSCORE sender context.
 *
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class GroupSenderCtx extends OSCoreCtx {</span>

	private final static int DEFAULT_MAX_UNFRAGMENTED_SIZE = 4096;

	GroupCtx commonCtx;
	OneKey ownPrivateKey;
<span class="fc" id="L44">	byte[] ownPublicKeyRaw = Bytes.EMPTY;</span>

	HashMap&lt;ByteId, byte[]&gt; pairwiseSenderKeys;

	GroupSenderCtx(byte[] master_secret, boolean client, AlgorithmID alg, byte[] sender_id, byte[] recipient_id,
			AlgorithmID kdf, Integer replay_size, byte[] master_salt, byte[] contextId, OneKey ownPrivateKey,
			byte[] ownPublicKeyRaw, GroupCtx commonCtx) throws OSException {
		// Build OSCORE Context using OSCoreCtx constructor
<span class="fc" id="L52">		super(master_secret, client, alg, sender_id, recipient_id, kdf, replay_size, master_salt, contextId,</span>
				DEFAULT_MAX_UNFRAGMENTED_SIZE);

<span class="fc" id="L55">		this.commonCtx = commonCtx;</span>
<span class="fc" id="L56">		this.ownPrivateKey = ownPrivateKey;</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">		if (ownPublicKeyRaw != null) {</span>
<span class="fc" id="L58">			this.ownPublicKeyRaw = ownPublicKeyRaw;</span>
		}

<span class="fc" id="L61">		pairwiseSenderKeys = new HashMap&lt;ByteId, byte[]&gt;();</span>

		// Set sender key based on used algGroupEnc
<span class="fc" id="L64">		this.sender_key = deriveSenderKey();</span>

<span class="fc" id="L66">	}</span>

	/**
	 * Derive sender key based on used algGroupEnc
	 * 
	 * @return the sender key
	 * @throws OSException on key derivation failure
	 */
	byte[] deriveSenderKey() throws OSException {

		// Set digest value depending on HKDF
<span class="fc" id="L77">		String digest = null;</span>
<span class="pc bpc" id="L78" title="1 of 3 branches missed.">		switch (this.getKdf()) {</span>
		case HKDF_HMAC_SHA_256:
		case HMAC_SHA_256:
<span class="fc" id="L81">			digest = &quot;SHA256&quot;;</span>
<span class="fc" id="L82">			break;</span>
		case HKDF_HMAC_SHA_512:
		case HMAC_SHA_512:
<span class="fc" id="L85">			digest = &quot;SHA512&quot;;</span>
<span class="fc" id="L86">			break;</span>
		case HKDF_HMAC_AES_128:
		case HKDF_HMAC_AES_256:
		default:
<span class="nc" id="L90">			throw new OSException(&quot;HKDF algorithm not supported&quot;);</span>
		}

<span class="fc" id="L93">		int keyLength = commonCtx.algGroupEnc.getKeySize() / 8;</span>

		// Derive sender_key
<span class="fc" id="L96">		CBORObject info = CBORObject.NewArray();</span>
<span class="fc" id="L97">		info.Add(sender_id);</span>
<span class="fc" id="L98">		info.Add(getIdContext());</span>
<span class="fc" id="L99">		info.Add(getCommonCtx().algGroupEnc.AsCBOR());</span>
<span class="fc" id="L100">		info.Add(CBORObject.FromObject(&quot;Key&quot;));</span>
<span class="fc" id="L101">		info.Add(keyLength);</span>

<span class="fc" id="L103">		byte[] derivedSenderKey = null;</span>
		try {
<span class="fc" id="L105">			derivedSenderKey = deriveKey(getMasterSecret(), getSalt(), keyLength, digest, info.EncodeToBytes());</span>
<span class="nc" id="L106">		} catch (CoseException e) {</span>
<span class="nc" id="L107">			throw new OSException(&quot;Failed to derive Sender Key&quot;);</span>
<span class="fc" id="L108">		}</span>
<span class="fc" id="L109">		return derivedSenderKey;</span>
	}

	/**
	 * Derive pairwise keys for this sender context and all associated recipient
	 * contexts
	 */
	void derivePairwiseKeys() {

<span class="fc bfc" id="L118" title="All 2 branches covered.">		for (Entry&lt;ByteId, GroupRecipientCtx&gt; entry : commonCtx.recipientCtxMap.entrySet()) {</span>
<span class="fc" id="L119">			GroupRecipientCtx recipientCtx = entry.getValue();</span>

<span class="fc" id="L121">			ByteId rid = new ByteId(recipientCtx.getRecipientId());</span>

			// If the key has already been generated skip it
<span class="fc bfc" id="L124" title="All 2 branches covered.">			if (pairwiseSenderKeys.get(rid) != null) {</span>
<span class="fc" id="L125">				continue;</span>
			}

<span class="fc" id="L128">			byte[] pairwiseSenderKey = commonCtx.derivePairwiseSenderKey(recipientCtx.getRecipientId(),</span>
<span class="fc" id="L129">					recipientCtx.getRecipientKey(), recipientCtx.getPublicKey(), recipientCtx.getPublicKeyRaw());</span>
<span class="fc" id="L130">			pairwiseSenderKeys.put(rid, pairwiseSenderKey);</span>

<span class="fc" id="L132">		}</span>
<span class="fc" id="L133">	}</span>

	/**
	 * Get if responses should use pairwise mode. // TODO: Implement elsewhere
	 * to avoid cast?
	 * 
	 * @return if responses should use pairwise mode
	 */
	public boolean getPairwiseModeResponses() {
<span class="fc" id="L142">		return commonCtx.pairwiseModeResponses;</span>
	}

	// TODO: Implement elsewhere to avoid cast?
	@Deprecated
	public boolean getPairwiseModeRequests() {
<span class="nc" id="L148">		return commonCtx.pairwiseModeRequests;</span>
	}

	/**
	 * Get the pairwise sender key for this context for a specific other
	 * recipient.
	 * 
	 * @param recipientId the recipient ID of the other party
	 * @return the pairwise sender key to recipient
	 */
	public byte[] getPairwiseSenderKey(byte[] recipientId) {
<span class="fc" id="L159">		return pairwiseSenderKeys.get(new ByteId(recipientId));</span>
	}

	// Just for interop tests
	public void setAsymmetricSenderKey(OneKey key) {
<span class="nc" id="L164">		ownPrivateKey = key;</span>
<span class="nc" id="L165">	}</span>

	/**
	 * Get the alg sign value.
	 * 
	 * @return the alg sign value
	 */
	public AlgorithmID getAlgSign() {
<span class="fc" id="L173">		return commonCtx.algSign;</span>
	}

	/**
	 * Get the alg sign enc value.
	 * 
	 * @return the alg sign enc value
	 */
	public AlgorithmID getAlgGroupEnc() {
<span class="fc" id="L182">		return commonCtx.algGroupEnc;</span>
	}

	/**
	 * Get the alg pairwise key agreement value.
	 * 
	 * @return the alg pairwise key agreement value.
	 */
	public AlgorithmID getAlgKeyAgreement() {
<span class="fc" id="L191">		return commonCtx.algKeyAgreement;</span>
	}

	/**
	 * Get the length of the countersignature depending on the countersignature
	 * algorithm currently used.
	 * 
	 * @return the length of the countersiganture
	 */
	public int getCountersignatureLen() {
<span class="fc" id="L201">		return commonCtx.getCountersignatureLen();</span>
	}

	/**
	 * Get the par countersign value for the external aad.
	 * 
	 * @return the par countersign value
	 */
	public int[][] getParCountersign() {
<span class="nc" id="L210">		return commonCtx.parCountersign;</span>
	}

	/**
	 * Get the alg countersign key value for the external aad.
	 * 
	 * @return the alg countersign key value
	 */
	public int[] getParCountersignKey() {
<span class="nc" id="L219">		return commonCtx.parCountersign[1];</span>
	}

	/**
	 * Get the private key associated to this sender context, meaning your own
	 * private key.
	 * 
	 * @return the private key
	 */
	public OneKey getPrivateKey() {
<span class="fc" id="L229">		return ownPrivateKey;</span>
	}

	/**
	 * Get the raw bytes of the public key associated to this sender context,
	 * meaning your own public key.
	 * 
	 * @return the bytes of the public key
	 */
	public byte[] getPublicKeyRaw() {
<span class="fc" id="L239">		return ownPublicKeyRaw;</span>
	}

	@Override
	protected GroupSenderCtx getSenderCtx() {
<span class="nc" id="L244">		return this;</span>
	}

	/**
	 * Get the common context associated to this GroupSenderCtx.
	 * 
	 * @return the common context associated to this GroupSenderCtx
	 */
	public GroupCtx getCommonCtx() {
<span class="fc" id="L253">		return commonCtx;</span>
	}

	// ------- TODO: Remove methods below -------

	public OneKey getPublicKey() {
<span class="nc" id="L259">		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span>
<span class="nc" id="L260">		System.err.println(&quot;Bad call to getPublicKey on GroupSenderCtx&quot; + stackTraceElements[2].toString());</span>
<span class="nc" id="L261">		return null;</span>
	}

	// Rikard: Generate a key to be used for Countersignatures
	public static void generateCounterSignKey(AlgorithmID alg) throws CoseException {
<span class="nc" id="L266">		OneKey myKey = OneKey.generateKey(alg);</span>

		// Print base64 encoded version with both public &amp; private keys
<span class="nc" id="L269">		byte[] keyObjectBytes = myKey.EncodeToBytes();</span>
<span class="nc" id="L270">		String base64_encoded = StringUtil.byteArrayToBase64(keyObjectBytes);</span>
<span class="nc" id="L271">		System.out.println(&quot;Public &amp; Private: &quot; + base64_encoded);</span>

		// Print base64 encoded version with only public keys
<span class="nc" id="L274">		OneKey publicKey = myKey.PublicKey();</span>

<span class="nc" id="L276">		keyObjectBytes = publicKey.EncodeToBytes();</span>
<span class="nc" id="L277">		base64_encoded = StringUtil.byteArrayToBase64(keyObjectBytes);</span>
<span class="nc" id="L278">		System.out.println(&quot;Public only: &quot; + base64_encoded);</span>

<span class="nc" id="L280">	}</span>

	// /**
	// * @return size of recipient replay window
	// */
	// @Override
	// public int getRecipientReplaySize() {
	// System.out.println(&quot;Bad call to getRecipientReplaySize&quot;);
	// StackTraceElement[] stackTraceElements =
	// Thread.currentThread().getStackTrace();
	// System.err.println(&quot;Bad call to getRecipientReplaySize on GroupSenderCtx&quot;
	// + stackTraceElements[2].toString());
	// Assert.fail();
	// return recipient_replay_window_size;
	// }
	//
	// /**
	// * @return recipient replay window
	// */
	// @Override
	// public int getRecipientReplayWindow() {
	// System.out.println(&quot;Bad call to getRecipientReplayWindow&quot;);
	// StackTraceElement[] stackTraceElements =
	// Thread.currentThread().getStackTrace();
	// System.err.println(&quot;Bad call to getRecipientReplayWindow on
	// GroupSenderCtx&quot; + stackTraceElements[2].toString());
	// Assert.fail();
	// return recipient_replay_window;
	// }

	@Override
	public void setRecipientKey(byte[] recipientKey) {
<span class="nc" id="L312">		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span>
<span class="nc" id="L313">		System.err.println(&quot;Bad call to setRecipientKey on GroupSenderCtx&quot; + stackTraceElements[2].toString());</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">		assert (false);</span>
<span class="nc" id="L315">		super.setRecipientKey(recipientKey);</span>
<span class="nc" id="L316">	}</span>

	// /**
	// * @param seq the recipient sequence number to set
	// */
	// public synchronized void setReceiverSeq(int seq) {
	// StackTraceElement[] stackTraceElements =
	// Thread.currentThread().getStackTrace();
	// System.err.println(&quot;Bad call to setReceiverSeq on GroupSenderCtx&quot; +
	// stackTraceElements[2].toString());
	// Assert.fail();
	// super.setReceiverSeq(seq);
	// }

	// public int rollbackRecipientSeq() {
	// StackTraceElement[] stackTraceElements =
	// Thread.currentThread().getStackTrace();
	// System.err.println(&quot;Bad call to rollbackRecipientSeq on GroupSenderCtx&quot; +
	// stackTraceElements[2].toString());
	// Assert.fail();
	// return super.rollbackRecipientSeq();
	// }
	//
	// public int rollbackRecipientReplay() {
	// StackTraceElement[] stackTraceElements =
	// Thread.currentThread().getStackTrace();
	// System.err.println(&quot;Bad call to rollbackRecipientReplay on
	// GroupSenderCtx&quot; + stackTraceElements[2].toString());
	// Assert.fail();
	// return super.rollbackRecipientReplay();
	// }

	/**
	 * @return the repipient's identifier
	 */
	@Override
	public byte[] getRecipientId() {
<span class="nc" id="L353">		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span>
		// System.err.println(&quot;Bad call to getRecipientId on GroupSenderCtx. &quot; +
		// stackTraceElements[1].toString());
<span class="nc" id="L356">		System.err.println(&quot;Bad call to getRecipientId on GroupSenderCtx. &quot; + stackTraceElements[2].toString());</span>
		// System.err.println(&quot;Bad call to getRecipientId on GroupSenderCtx. &quot; +
		// stackTraceElements[3].toString());
<span class="nc bnc" id="L359" title="All 2 branches missed.">		assert (false);</span>
<span class="nc" id="L360">		return super.getRecipientId();</span>
	}

	/**
	 * @return get the receiver sequence number
	 */
	public synchronized int getReceiverSeq() {
<span class="nc" id="L367">		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span>
<span class="nc" id="L368">		System.err.println(&quot;Bad call to getReceiverSeq on GroupSenderCtx&quot; + stackTraceElements[2].toString());</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		assert (false);</span>
<span class="nc" id="L370">		return super.getLowestRecipientSeq();</span>
	}

	/**
	 * @return get the recipient key
	 */
	@Override
	public byte[] getRecipientKey() {
<span class="nc" id="L378">		StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span>
<span class="nc" id="L379">		System.err.println(&quot;Bad call to getRecipientKey on GroupSenderCtx&quot; + stackTraceElements[2].toString());</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		assert (false);</span>
<span class="nc" id="L381">		return super.getRecipientKey();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>