<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ACE library</a> &gt; <a href="index.source.html" class="el_package">se.sics.ace</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">package se.sics.ace;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.californium.core.CoapResponse;
import org.eclipse.californium.core.coap.Response;

import com.upokecenter.cbor.CBORObject;
import com.upokecenter.cbor.CBORType;

import org.eclipse.californium.cose.AlgorithmID;
import org.eclipse.californium.cose.CoseException;
import org.eclipse.californium.cose.KeyKeys;
import org.eclipse.californium.cose.OneKey;
import net.i2p.crypto.eddsa.Utils;
import se.sics.ace.rs.TokenRepository;

<span class="nc" id="L31">public class Util {</span>

    /**
     *  Convert a positive integer into a byte array of minimal size.
     *  The positive integer can be up to 2,147,483,647
     * @param num
     * @return  the byte array
     */
    public static byte[] intToBytes(final int num) {
<span class="fc" id="L40">    	return intToBytes(num, 0);</span>
    }
	
    /**
     *  Convert a positive integer into a byte array of the specified length (in bytes).
     *  If the specified length is 0, the byte array will be of minimal size.
     *  The positive integer can be up to 2,147,483,647
     * @param num
     * @param length
     * @return  the byte array
     */
    public static byte[] intToBytes(final int num, final int length) {

<span class="fc" id="L53">    	byte[] ret = null;</span>
    	
    	// Big-endian
<span class="pc bpc" id="L56" title="2 of 4 branches missed.">    	if (num &lt; 0 || length &lt; 0)</span>
<span class="nc" id="L57">    		return null;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        else if (num &lt; 256) {</span>
<span class="fc" id="L59">            ret = new byte[] { (byte) (num) };</span>
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        } else if (num &lt; 65536) {</span>
<span class="fc" id="L61">        	ret = new byte[] { (byte) (num &gt;&gt;&gt; 8), (byte) num };</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        } else if (num &lt; 16777216) {</span>
<span class="nc" id="L63">        	ret = new byte[] { (byte) (num &gt;&gt;&gt; 16), (byte) (num &gt;&gt;&gt; 8), (byte) num };</span>
        } else { // up to 2,147,483,647
<span class="nc" id="L65">        	ret = new byte[]{ (byte) (num &gt;&gt;&gt; 24), (byte) (num &gt;&gt;&gt; 16), (byte) (num &gt;&gt;&gt; 8), (byte) num };</span>
        }
    	
    	// Little-endian
    	/*
    	if (num &lt; 0)
    		return null;
        else if (num &lt; 256) {
            ret = new byte[] { (byte) (num) };
        } else if (num &lt; 65536) {
            ret = new byte[] { (byte) num, (byte) (num &gt;&gt;&gt; 8) };
        } else if (num &lt; 16777216){
            ret = new byte[] { (byte) num, (byte) (num &gt;&gt;&gt; 8), (byte) (num &gt;&gt;&gt; 16) };
        } else{ // up to 2,147,483,647
            ret = new byte[] { (byte) num, (byte) (num &gt;&gt;&gt; 8), (byte) (num &gt;&gt;&gt; 16), (byte) (num &gt;&gt;&gt; 24) };
        }
    	*/
    	
<span class="fc bfc" id="L83" title="All 4 branches covered.">    	if (length == 0 || length &lt;= ret.length)</span>
<span class="fc" id="L84">    		return ret;</span>
    	
<span class="fc" id="L86">    	int paddingLength = length - ret.length;</span>
<span class="fc" id="L87">    	byte[] retWithPadding = new byte[ret.length + paddingLength];</span>
    	
    	// Big-endian
<span class="fc bfc" id="L90" title="All 2 branches covered.">    	for (int i = 0; i &lt; paddingLength; i++)</span>
<span class="fc" id="L91">    		retWithPadding[i] = (byte) 0x00;</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">    	for (int i = 0; i &lt; ret.length; i++)</span>
<span class="fc" id="L93">    		retWithPadding[i + paddingLength] = ret[i];</span>
    	
    	// Little-endian
    	/*
    	for (int i = 0; i &lt; ret.length; i++)
    		retWithPadding[i] = ret[i];
    	for (int i = 0; i &lt; paddingLength; i++)
    		retWithPadding[i + paddingLength] = (byte) 0x00;
    	*/
    	
<span class="fc" id="L103">    	return retWithPadding;</span>
    	
    }
	
    /**
     * Convert a byte array into an equivalent unsigned integer.
     * The input byte array can be up to 4 bytes in size.
     *
     * N.B. If the input array is 4 bytes in size, the returned integer may be negative!
     *      The calling method has to check, if relevant!
     * 
     * @param bytes 
     * @return   the converted integer
     */
    public static int bytesToInt(final byte[] bytes) {
    	
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    	if (bytes.length &gt; 4)</span>
<span class="nc" id="L120">    		return -1;</span>
    	
<span class="fc" id="L122">    	int ret = 0;</span>

    	// Big-endian
<span class="fc bfc" id="L125" title="All 2 branches covered.">    	for (int i = 0; i &lt; bytes.length; i++)</span>
<span class="fc" id="L126">    		ret = ret + (bytes[bytes.length - 1 - i] &amp; 0xFF) * (int) (Math.pow(256, i));</span>

    	/*
    	// Little-endian
    	for (int i = 0; i &lt; bytes.length; i++)
    		ret = ret + (bytes[i] &amp; 0xFF) * (int) (Math.pow(256, i));
    	*/
    	
<span class="fc" id="L134">    	return ret;</span>
    	
    }
	
    /**
     * Build the &quot;psk_identity&quot; to use in the
     * ClientKeyExchange DTLS Handshake message
     *  
     * @param kid   The 'kid' of the key used as PoP key
     * 
     * @return The &quot;psk_identity&quot; to use in the DTLS Handshake
     */
	public static byte[] buildDtlsPskIdentity(byte[] kid) {
        
<span class="fc" id="L148">        CBORObject identityMap = CBORObject.NewMap();</span>
<span class="fc" id="L149">        CBORObject cnfMap = CBORObject.NewMap();</span>
<span class="fc" id="L150">        CBORObject coseKeyMap = CBORObject.NewMap();</span>
        
<span class="fc" id="L152">        coseKeyMap.Add(CBORObject.FromObject(KeyKeys.KeyType.AsCBOR()), KeyKeys.KeyType_Octet);</span>
<span class="fc" id="L153">        coseKeyMap.Add(CBORObject.FromObject(KeyKeys.KeyId.AsCBOR()), kid);</span>
<span class="fc" id="L154">        cnfMap.Add(Constants.COSE_KEY_CBOR, coseKeyMap);</span>
<span class="fc" id="L155">        identityMap.Add(CBORObject.FromObject(Constants.CNF), cnfMap);</span>
        
        // The serialized identity map to use as &quot;psk_identity&quot; in DTLS
<span class="fc" id="L158">        return identityMap.EncodeToBytes();</span>
		
	}
	
    /**
     * Compute a digital signature
     * 
     * @param signKeyCurve   Elliptic curve used to compute the signature
     * @param privKey  private key of the signer, used to compute the signature
     * @param dataToSign  content to sign
     * @return The computed signature, or null in case of error
     
     */
    public static byte[] computeSignature(int signKeyCurve, PrivateKey privKey, byte[] dataToSign) {

<span class="fc" id="L173">        Signature signCtx = null;</span>
<span class="fc" id="L174">        byte[] signature = null;</span>

        try {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">     	   if (signKeyCurve == KeyKeys.EC2_P256.AsInt32())</span>
<span class="nc" id="L178">     		  signCtx = Signature.getInstance(&quot;SHA256withECDSA&quot;);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">     	   else if (signKeyCurve == KeyKeys.OKP_Ed25519.AsInt32())</span>
<span class="fc" id="L180">     		  signCtx = Signature.getInstance(&quot;NonewithEdDSA&quot;, &quot;EdDSA&quot;);</span>
     	   else {
     		  // At the moment, only ECDSA (EC2_P256) and EDDSA (Ed25519) are supported
<span class="nc" id="L183">     		  System.err.println(&quot;Unsupported signature algorithm&quot;);</span>
<span class="nc" id="L184">     		  return null;</span>
     	   }
            
        }
<span class="nc" id="L188">        catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L189">            System.err.println(&quot;Unsupported signature algorithm: &quot; + e.getMessage());</span>
<span class="nc" id="L190">            return null;</span>
        }
<span class="nc" id="L192">        catch (NoSuchProviderException e) {</span>
<span class="nc" id="L193">            System.err.println(&quot;Unsopported security provider for signature computing: &quot; + e.getMessage());</span>
<span class="nc" id="L194">            return null;</span>
<span class="fc" id="L195">        }</span>
        
        try {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if (signCtx != null)</span>
<span class="fc" id="L199">            	signCtx.initSign(privKey);</span>
            else {
<span class="nc" id="L201">                System.err.println(&quot;Signature algorithm has not been initialized&quot;);</span>
<span class="nc" id="L202">                return null;</span>
            }
        }
<span class="nc" id="L205">        catch (InvalidKeyException e) {</span>
<span class="nc" id="L206">            System.err.println(&quot;Invalid key excpetion - Invalid private key: &quot; + e.getMessage());</span>
<span class="nc" id="L207">            return null;</span>
<span class="fc" id="L208">        }</span>
        
        try {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        	if (signCtx != null) {</span>
<span class="fc" id="L212">        		signCtx.update(dataToSign);</span>
<span class="fc" id="L213">        		signature = signCtx.sign();</span>
        	}
<span class="nc" id="L215">        } catch (SignatureException e) {</span>
<span class="nc" id="L216">            System.err.println(&quot;Failed signature computation: &quot; + e.getMessage());</span>
<span class="nc" id="L217">            return null;</span>
<span class="fc" id="L218">        }</span>
        
<span class="fc" id="L220">        return signature;</span>
        
    }
    
    /**
     * Verify the correctness of a digital signature
     * 
     * @param signKeyCurve   Elliptic curve used to process the signature
     * @param pubKey   Public key of the signer, used to verify the signature
     * @param signedData   Data over which the signature has been computed
     * @param expectedSignature   Signature to verify
     * @return True if the signature verifies correctly, false otherwise
     */
    public static boolean verifySignature(int signKeyCurve, PublicKey pubKey, byte[] signedData, byte[] expectedSignature) {

<span class="fc" id="L235">        Signature signature = null;</span>
<span class="fc" id="L236">        boolean success = false;</span>
        
        try {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">           if (signKeyCurve == KeyKeys.EC2_P256.AsInt32())</span>
<span class="nc" id="L240">        	   signature = Signature.getInstance(&quot;SHA256withECDSA&quot;);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">           else if (signKeyCurve == KeyKeys.OKP_Ed25519.AsInt32())</span>
<span class="fc" id="L242">        	   signature = Signature.getInstance(&quot;NonewithEdDSA&quot;, &quot;EdDSA&quot;);</span>
           else {
<span class="nc" id="L244">              System.err.println(&quot;Unsupported signature algorithm&quot;);</span>
<span class="nc" id="L245">              return false;</span>
           }
             
         }
<span class="nc" id="L249">         catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L250">             System.err.println(&quot;Unsupported signature algorithm: &quot; + e.getMessage());</span>
<span class="nc" id="L251">             return false;</span>
         }
<span class="nc" id="L253">         catch (NoSuchProviderException e) {</span>
<span class="nc" id="L254">             System.err.println(&quot;Unsopported security provider for signature computing: &quot; + e.getMessage());</span>
<span class="nc" id="L255">             return false;</span>
<span class="fc" id="L256">         }</span>
         
         try {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">             if (signature != null)</span>
<span class="fc" id="L260">            	 signature.initVerify(pubKey);</span>
             else {
<span class="nc" id="L262">                 System.err.println(&quot;Signature algorithm has not been initialized&quot;);</span>
<span class="nc" id="L263">                 return false;</span>
             }
         }
<span class="nc" id="L266">         catch (InvalidKeyException e) {</span>
<span class="nc" id="L267">             System.err.println(&quot;Invalid key excpetion - Invalid public key: &quot; + e.getMessage());</span>
<span class="nc" id="L268">             return false;</span>
<span class="fc" id="L269">         }</span>
         
         try {
<span class="fc" id="L272">        	 signature.update(signedData);</span>
<span class="fc" id="L273">             success = signature.verify(expectedSignature);</span>
<span class="nc" id="L274">         } catch (SignatureException e) {</span>
<span class="nc" id="L275">             System.err.println(&quot;Error during signature verification: &quot; + e.getMessage());</span>
<span class="nc" id="L276">             return false;</span>
<span class="fc" id="L277">         }</span>
         
<span class="fc" id="L279">         return success;</span>

    }
    
    /**
     * Return the cryptographic curve to use for a Signature Algorithm or for a Pairwise Key Agreement Algorithm
     * in an OSCORE group, depending on whether the group uses the group mode or not, respectively
     * 
     * @param parameters   A CBOR Map, specifying the parameters for a Signature Algorithm or
     *                     for a Pairwise Key Agreement Algorithm to use in an OSCORE group
     * 
     * @return The cryptographic curve, as a CBOR Object with value an integer, or null in case of error
     */
    public static CBORObject retrieveCurve(final CBORObject parameters) {
    	
<span class="fc" id="L294">    	CBORObject curve = null;</span>
    	
<span class="fc" id="L296">    	CBORObject keyType = parameters.get(0).get(0);</span>
    	
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">    	if (keyType == null) {</span>
<span class="nc" id="L299">    		return null;</span>
    	}
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">		if (keyType.equals(org.eclipse.californium.cose.KeyKeys.KeyType_OKP)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">				|| keyType.equals(org.eclipse.californium.cose.KeyKeys.KeyType_EC2)) {</span>
<span class="fc" id="L303">    		curve = parameters.get(1).get(1);</span>
    	}
    	
<span class="fc" id="L306">    	return curve;</span>
    	
    }
    
    /**
     * Return the asymmetric key pair of the Group Manager to use, as a OneKey object
     * 
     * @param gmSigningKeyPairs   Asymmetric key pairs of the Group Manager, to be used for signing operations.
     *                            The map key is the cryptographic curve; the map value is the hex string of the key pair
     * @param gmKeyAgreementKeyPairs   Asymmetric key pairs of the Group Manager, to be used for key agreement operations.
     *                                 The map key is the cryptographic curve; the map value is the hex string of the key pair
     * @param useGroupMode   True if the OSCORE group uses the group mode, or false otherwise
     * @param parameters   A CBOR Map, specifying the parameters for the Signature Algorithm or
     *                     for the Pairwise Key Agreement Algorithm, depending on 'useGroupMode'
     *                     being True of False, respectively
     * 
     * @return The asymmetric key pair of the Group Manager to use, or null in case of error
     */
    public static OneKey retrieveGmKeyPair(final Map&lt;CBORObject, String&gt; gmSigningKeyPairs,
    								       final Map&lt;CBORObject, String&gt; gmKeyAgreementKeyPairs,
    							     	   final boolean useGroupMode,
    								       final CBORObject parameters) {
    	
<span class="fc" id="L329">    	OneKey gmKeyPair = null;</span>
    	
    	// Serialization of the COSE Key including both private and public part
<span class="fc" id="L332">    	byte[] gmKeyPairBytes = null;</span>
    	
<span class="fc" id="L334">    	CBORObject curve = retrieveCurve(parameters);</span>
    	
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    	if (curve == null) {</span>
    		// This should never happen
<span class="nc" id="L338">    		return null;</span>
    	}

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    	if (useGroupMode) {</span>
    		// This group uses the group mode, thus the authentication credential
    		// of the Group Manager has to be specific for signing operations
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.EC2_P256.AsInt32()) {</span>
<span class="nc" id="L345">				gmKeyPairBytes = Utils.hexToBytes(gmSigningKeyPairs.get(org.eclipse.californium.cose.KeyKeys.EC2_P256));</span>
    		}
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.OKP_Ed25519.AsInt32()) {</span>
<span class="fc" id="L348">				gmKeyPairBytes = Utils</span>
<span class="fc" id="L349">						.hexToBytes(gmSigningKeyPairs.get(org.eclipse.californium.cose.KeyKeys.OKP_Ed25519));</span>
    		}
    	}
    	else {
    		// This group uses only the pairwise mode, thus the authentication credential
    		// of the Group Manager has to be specific for key agreement operations
<span class="nc bnc" id="L355" title="All 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.EC2_P256.AsInt32()) {</span>
<span class="nc" id="L356">				gmKeyPairBytes = Utils</span>
<span class="nc" id="L357">						.hexToBytes(gmKeyAgreementKeyPairs.get(org.eclipse.californium.cose.KeyKeys.EC2_P256));</span>
    		}
<span class="nc bnc" id="L359" title="All 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.OKP_X25519.AsInt32()) {</span>
<span class="nc" id="L360">				gmKeyPairBytes = Utils</span>
<span class="nc" id="L361">						.hexToBytes(gmKeyAgreementKeyPairs.get(org.eclipse.californium.cose.KeyKeys.OKP_X25519));</span>
    		}
    	}
    	    	
    	try {
<span class="fc" id="L366">			gmKeyPair = new OneKey(CBORObject.DecodeFromBytes(gmKeyPairBytes));</span>
<span class="nc" id="L367">		} catch (CoseException e) {</span>
<span class="nc" id="L368">			e.printStackTrace();</span>
<span class="nc" id="L369">    		return null;</span>
<span class="fc" id="L370">		}</span>
    	
<span class="fc" id="L372">    	return gmKeyPair;</span>
    	
    }
    
    /**
     * Return the authentication credential of the Group Manager to use, as a byte array
     * 
     * @param credFmt                   The format of public authentication credentials used in the OSCORE group 
     * @param gmSigningPublicAuthCred   The public authentication credentials of the Group Manager,
     *                                  including a public key to be used for key agreement operations.
     *                                  For the outer map, the map key is the type of authentication credential.
     *                                  For the inner map, the map key is the cryptographic curve,
     *                                  while the map value is the hex string of the authentication credential
     * @param gmKeyAgreementPublicAuthCred   The public authentication credentials of the Group Manager,
     *                                       including a public key to be used for key agreement operations.
     *                                       For the outer map, the map key is the type of authentication credential.
     *                                       For the inner map, the map key is the cryptographic curve,
     *                                       while the map value is the hex string of the authentication credential
     * @param useGroupMode   True if the OSCORE group uses the group mode, or false otherwise
     * @param parameters   A CBOR Map, specifying the parameters for the Signature Algorithm or
     *                     for the Pairwise Key Agreement Algorithm, depending on 'useGroupMode'
     *                     being True of False, respectively
     * 
     * @return The authentication credential of the Group Manager to use, or null in case of error
     */
    public static byte[] retrieveGmAuthCred(final int credFmt, 
    								        final Map&lt;Integer,  Map&lt;CBORObject, String&gt;&gt; gmSigningPublicAuthCred,
    								        final Map&lt;Integer,  Map&lt;CBORObject, String&gt;&gt; gmKeyAgreementPublicAuthCred,
    								        final boolean useGroupMode,
    								        final CBORObject parameters) {
    	
<span class="fc" id="L403">    	byte[] gmAuthCred = null;</span>
    	
<span class="fc" id="L405">    	CBORObject curve = retrieveCurve(parameters);</span>
    	
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    	if (curve == null) {</span>
    		// This should never happen
<span class="nc" id="L409">    		return null;</span>
    	}
    	
    	// Build the authentication credential according to the format used in the group
<span class="pc bpc" id="L413" title="3 of 4 branches missed.">    	switch (credFmt) {</span>
	        case Constants.COSE_HEADER_PARAM_KCCS:
	            // A CCS including the public key
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.EC2_P256.AsInt32()) {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">	        		if (useGroupMode) {</span>
<span class="nc" id="L418">					gmAuthCred = Utils.hexToBytes(gmSigningPublicAuthCred.get(Constants.COSE_HEADER_PARAM_KCCS)</span>
<span class="nc" id="L419">							.get(org.eclipse.californium.cose.KeyKeys.EC2_P256));</span>
		        		// gmAuthCred = Utils.hexToBytes(&quot;A2026008A101A50102032620012158202236658CA675BB62D7B24623DB0453A3B90533B7C3B221CC1C2C73C4E919D540225820770916BC4C97C3C46604F430B06170C7B3D6062633756628C31180FA3BB65A1B&quot;);
	        		}
	        		else {
<span class="nc" id="L423">					gmAuthCred = Utils.hexToBytes(gmKeyAgreementPublicAuthCred.get(Constants.COSE_HEADER_PARAM_KCCS)</span>
<span class="nc" id="L424">							.get(org.eclipse.californium.cose.KeyKeys.EC2_P256));</span>
	        		}		
	        	}
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.OKP_Ed25519.AsInt32()) {</span>
<span class="fc" id="L428">				gmAuthCred = Utils.hexToBytes(gmSigningPublicAuthCred.get(Constants.COSE_HEADER_PARAM_KCCS)</span>
<span class="fc" id="L429">						.get(org.eclipse.californium.cose.KeyKeys.OKP_Ed25519));</span>
	        		// gmAuthCred = Utils.hexToBytes(&quot;A2026008A101A4010103272006215820C6EC665E817BD064340E7C24BB93A11E8EC0735CE48790F9C458F7FA340B8CA3&quot;);
	        	}
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">			if (curve.AsInt32() == org.eclipse.californium.cose.KeyKeys.OKP_X25519.AsInt32()) {</span>
<span class="nc" id="L433">				gmAuthCred = Utils.hexToBytes(gmKeyAgreementPublicAuthCred.get(Constants.COSE_HEADER_PARAM_KCCS)</span>
<span class="nc" id="L434">						.get(org.eclipse.californium.cose.KeyKeys.OKP_X25519));</span>
	        	}
	            break;
	        case Constants.COSE_HEADER_PARAM_KCWT:
	            // A CWT including the public key
	            // TODO
<span class="nc" id="L440">	        	gmAuthCred = null;</span>
<span class="nc" id="L441">	            break;</span>
	        case Constants.COSE_HEADER_PARAM_X5CHAIN:
	            // A certificate including the public key
	            // TODO
<span class="nc" id="L445">	        	gmAuthCred = null;</span>
	            break;
    	}
    	
<span class="fc" id="L449">    	return gmAuthCred;</span>
    	
    }
    
    /**
     * Add 'newRole' to the role set, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param currentRoleSet  the current set of roles
     * @param newRole  the role to add to the current set
     * 
      * @return  the updated role set
      * @throws AceException  if the role identifier is less than 1
     */
    public static int addGroupOSCORERole (int currentRoleSet, short newRole) throws AceException {

<span class="pc bpc" id="L464" title="1 of 2 branches missed.">   	 if (newRole &lt; 1) throw new AceException(&quot;Invalid identifier of Group OSCORE role&quot;);</span>
   	 
<span class="fc" id="L466">   	 int updatedRoleSet = 0;</span>
<span class="fc" id="L467">   	 updatedRoleSet = currentRoleSet | (1 &lt;&lt; newRole);</span>
   	 
<span class="fc" id="L469">   	 return updatedRoleSet; </span>
   	 
    }
    
    /**
     * Remove 'oldRole' from the role set, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param currentRoleSet  the current set of roles
     * @param oldRole  the role to remove from the current set
     * 
      * @return  the updated role set
      * @throws AceException  if the role identifier is less than 1
     */
    public static int removeGroupOSCORERole (int currentRoleSet, short oldRole) throws AceException {

<span class="nc bnc" id="L484" title="All 2 branches missed.">   	 if (oldRole &lt; 1) throw new AceException(&quot;Invalid identifier of Group OSCORE role&quot;);</span>
   	 
<span class="nc" id="L486">   	 int updatedRoleSet = 0;</span>
<span class="nc" id="L487">   	 updatedRoleSet = currentRoleSet &amp; (~(1 &lt;&lt; oldRole));</span>
   	 
<span class="nc" id="L489">   	 return updatedRoleSet; </span>
   	 
    }
       
    /**
     * Check if a role set includes a specified role, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param roleSet  the set of roles
     * @param role  the role to remove from the current set
     * 
      * @return  true if the role set includes the specified role, false otherwise
      * @throws AceException  if the set of roles is inconsistent with the AIF-OSCORE-GROUPCOMM data model
      * 					  or the role identifier is less than 1
     */
    public static boolean checkGroupOSCORERole (int roleSet, short role) throws AceException {
   	 
<span class="nc bnc" id="L505" title="All 4 branches missed.">   	 if ((roleSet &lt; 1) || ((roleSet % 2) == 1)) {</span>
<span class="nc" id="L506">   		 throw new AceException(&quot;Invalid set of Group OSCORE roles&quot;);</span>
   	 }
   	 
<span class="nc bnc" id="L509" title="All 2 branches missed.">   	 if (role &lt; 1) {</span>
<span class="nc" id="L510">   		 throw new AceException(&quot;Invalid identifier of Group OSCORE role&quot;);</span>
   	 }
   	 
<span class="nc bnc" id="L513" title="All 2 branches missed.">   	 return ((roleSet &amp; (1 &lt;&lt; role)) != 0);</span>
   	 
    }
    
    /**
     * Return the array of roles included in the specified role set, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param roleSet  the set of roles, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
      * @return  The set of role identifiers specified in the role set
      * @throws AceException  if the set of roles is inconsistent with the AIF-OSCORE-GROUPCOMM data model
     */
    public static Set&lt;Integer&gt; getGroupOSCORERoles (int roleSet) throws AceException {
   	 
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">      	 if ((roleSet &lt; 1) || ((roleSet % 2) == 1)) {</span>
<span class="nc" id="L528">       		 throw new AceException(&quot;Invalid set of Group OSCORE roles&quot;);</span>
       	 }
	   	 
<span class="fc" id="L531">	   	 Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L532">	   	 int roleIdentifier = 0;</span>
	   	 
<span class="fc bfc" id="L534" title="All 2 branches covered.">	   	 while (roleSet != 0) {</span>
<span class="fc" id="L535">	   		 roleSet = roleSet &gt;&gt;&gt; 1;</span>
<span class="fc" id="L536">	   	 	 roleIdentifier++;</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">	   	 	 if ((roleSet &amp; 1) != 0) {</span>
<span class="fc" id="L538">	   	 		 mySet.add(Integer.valueOf(roleIdentifier));</span>
	   	 	 }
	   	 }
	   	 
<span class="fc" id="L542">	   	 return mySet;</span>
   	 
    }
    
    /**
     * Return the role sets allowed to a subject in a group, based on all the Access Tokens for that subject
     * 
     * @param subject   Subject identity of the node
     * @param groupName   Group name of the OSCORE group
     * @return The sets of allowed roles for the subject in the specified group using the AIF data model,
     *         or null in case of no results
     */
    public static int[] getGroupOSCORERolesFromToken(String subject, String groupName) {

<span class="fc" id="L556">    	Set&lt;Integer&gt; roleSets = new HashSet&lt;Integer&gt;();</span>
    	
<span class="fc" id="L558">    	String kid = TokenRepository.getInstance().getKid(subject);</span>
<span class="fc" id="L559">    	Set&lt;String&gt; ctis = TokenRepository.getInstance().getCtis(kid);</span>
    	
    	// This should never happen at this point, since a valid Access Token
    	// has just made this request pass through 
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">    	if (ctis == null)</span>
<span class="nc" id="L564">    		return null;</span>
    	
<span class="fc bfc" id="L566" title="All 2 branches covered.">    	for (String cti : ctis) { // All tokens linked to that pop key</span>
    		
	        // Check if we have the claims for that cti
    		
	        // Get the claims
<span class="fc" id="L571">            Map&lt;Short, CBORObject&gt; claims = TokenRepository.getInstance().getClaims(cti);</span>
<span class="pc bpc" id="L572" title="2 of 4 branches missed.">            if (claims == null || claims.isEmpty()) {</span>
                // No claims found
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L575">                continue;</span>
            }
            
	        //Check the scope
<span class="fc" id="L579">            CBORObject scope = claims.get(Constants.SCOPE);</span>
            
        	// This should never happen, since a valid Access Token
            // has just reached a handler at the Group Manager
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (scope == null) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L585">            	continue;</span>
            }
            
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            if (!scope.getType().equals(CBORType.ByteString)) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L590">            	continue;</span>
            }
            
<span class="fc" id="L593">            byte[] rawScope = scope.GetByteString();</span>
<span class="fc" id="L594">        	CBORObject cborScope = CBORObject.DecodeFromBytes(rawScope);</span>
        	
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        	if (!cborScope.getType().equals(CBORType.Array)) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L598">                continue;</span>
            }

<span class="fc bfc" id="L601" title="All 2 branches covered.">        	for (int entryIndex = 0; entryIndex &lt; cborScope.size(); entryIndex++) {</span>
            	
<span class="fc" id="L603">        		CBORObject scopeEntry = cborScope.get(entryIndex);</span>
        		
<span class="pc bpc" id="L605" title="2 of 4 branches missed.">        		if (!scopeEntry.getType().equals(CBORType.Array) || scopeEntry.size() != 2) {</span>
        			// Move to the next Access Token for this 'kid'
<span class="nc" id="L607">                    break;</span>
                }
	        	
	        	// Retrieve the group name of the OSCORE group
	        	String scopeStr;
<span class="fc" id="L612">	      	  	CBORObject scopeElement = scopeEntry.get(0);</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">	      	  	if (scopeElement.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L614">	      	  		scopeStr = scopeElement.AsString();</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">	      	  		if (!scopeStr.equals(groupName)) {</span>
	      	  		    // Move to the next scope entry
<span class="fc" id="L617">	      	  			continue;</span>
	      	  		}
	      	  	}
	      	  	else {
	      	  		// Move to the next scope entry
	                continue;
	      	  	}
	      	  	
	      	  	// Retrieve the role or list of roles
<span class="fc" id="L626">	      	  	scopeElement = scopeEntry.get(1);</span>
	      	  	
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">	        	if (!scopeElement.getType().equals(CBORType.Integer)) {</span>
      	  		    // Move to the next scope entry
<span class="nc" id="L630">      	  			continue;</span>
	        	}
	        	
<span class="fc" id="L633">        		int roleSetToken = scopeElement.AsInt32();</span>
        		
        		// According to the AIF-OSCORE-GROUPCOMM data model, a valid combination 
        		// of roles has to be a positive integer of even value (i.e., with last bit 0)
<span class="pc bpc" id="L637" title="1 of 4 branches missed.">        		if (roleSetToken &lt;= 0 || (roleSetToken % 2 == 1)) {</span>
      	  		    // Move to the next scope entry
<span class="fc" id="L639">      	  			continue;</span>
        		}

<span class="fc" id="L642">        		roleSets.add(roleSetToken);</span>
        			        	
        	}
        	
<span class="fc" id="L646">    	}</span>
    	    	
    	// No Access Token allows this node to have any role
    	// with respect to the specified group
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">    	if (roleSets.size() == 0) {</span>
<span class="nc" id="L651">    		return null;</span>
    	}
    	else {
<span class="fc" id="L654">    		int[] ret = new int[roleSets.size()];</span>
    		
<span class="fc" id="L656">    		int index = 0;</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">    		for (Integer i : roleSets) {</span>
<span class="fc" id="L658">    			ret[index] = i.intValue();</span>
<span class="fc" id="L659">    			index++;</span>
<span class="fc" id="L660">    		}</span>
    		
<span class="fc" id="L662">    		return ret;</span>
    	}
    	
    }
    
    /**
     * Add 'newPermission' to the admin permission set, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param currentPermissionSet  the current set of admin permissions
     * @param newPermission  the admin permission to add to the current set
     * 
      * @return  the updated set of admin permission
      * @throws AceException  if the permission identifier is less than 1
     */
    public static int addGroupOSCOREAdminPermission (int currentPermissionSet, short newPermission) throws AceException {

<span class="pc bpc" id="L678" title="1 of 2 branches missed.">   	 if (newPermission &lt; 0) throw new AceException(&quot;Invalid identifier of Group OSCORE admin permission&quot;);</span>
   	 
<span class="fc" id="L680">   	 int updatedPermissionSet = 0;</span>
<span class="fc" id="L681">   	 updatedPermissionSet = currentPermissionSet | (1 &lt;&lt; newPermission);</span>
   	 
<span class="fc" id="L683">   	 return updatedPermissionSet; </span>
   	 
    }
    
    /**
     * Remove 'oldPermission' from the admin permission set, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param currentPermissionSet  the current set of admin permissions
     * @param oldPermission  the permission to remove from the current set
     * 
      * @return  the updated set of admin permissions
      * @throws AceException  if the permission identifier is less than 1
     */
    public static int removeGroupOSCOREAdminPermission (int currentPermissionSet, short oldPermission) throws AceException {

<span class="nc bnc" id="L698" title="All 2 branches missed.">   	 if (oldPermission &lt; 0) throw new AceException(&quot;Invalid identifier of Group OSCORE admin permission&quot;);</span>
   	 
<span class="nc" id="L700">   	 int updatedPermissionSet = 0;</span>
<span class="nc" id="L701">   	 updatedPermissionSet = currentPermissionSet &amp; (~(1 &lt;&lt; oldPermission));</span>
   	 
<span class="nc" id="L703">   	 return updatedPermissionSet; </span>
   	 
    }
    
    /**
     * Check if a permission set includes a specified admin permission, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param permissionSet  the set of admin permissions
     * @param permission  the permission whose presence has to be checked in the set of admin permissions
     * 
      * @return  true if the permission set includes the specified admin permission, false otherwise
      * @throws AceException  if the set of admin permissions is inconsistent with the AIF-OSCORE-GROUPCOMM data model
      * 					  or the permission identifier is less than 1
     */
    public static boolean checkGroupOSCOREAdminPermission (int permissionSet, short permission) throws AceException {
   	 
<span class="pc bpc" id="L719" title="2 of 4 branches missed.">   	 if ((permissionSet &lt; 1) || ((permissionSet % 2) == 0)) {</span>
<span class="nc" id="L720">   		 throw new AceException(&quot;Invalid set of Group OSCORE admin permissions&quot;);</span>
   	 }
   	 
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">   	 if (permission &lt; 0) {</span>
<span class="nc" id="L724">   		 throw new AceException(&quot;Invalid identifier of Group OSCORE admin permission&quot;);</span>
   	 }
   	 
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">   	 return ((permissionSet &amp; (1 &lt;&lt; permission)) != 0);</span>
   	 
    }
    
    /**
     * Return the array of permissions included in the specified set of admin permissions,
     * encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
     * @param permissionSet  the set of admin permissions, encoded using the AIF-OSCORE-GROUPCOMM data model
     * 
      * @return  The set of permission identifiers specified in the set of admin permission
      * @throws AceException  if the set of permissions is inconsistent with the AIF-OSCORE-GROUPCOMM data model
     */
    public static Set&lt;Integer&gt; getGroupOSCOREAdminPermissions (int permissionSet) throws AceException {
   	 
<span class="pc bpc" id="L742" title="2 of 4 branches missed.">      	 if ((permissionSet &lt; 1) || ((permissionSet % 2) == 0)) {</span>
<span class="nc" id="L743">       		 throw new AceException(&quot;Invalid set of Group OSCORE admin permissions&quot;);</span>
       	 }
	   	 
<span class="fc" id="L746">	   	 Set&lt;Integer&gt; mySet = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L747">	   	 int permissionIdentifier = 0;</span>
	   	 
	   	 // The admin permission &quot;List&quot; is always set in every admin scope entry
<span class="fc" id="L750">	   	 mySet.add(Integer.valueOf(permissionIdentifier));</span>
	   	 
<span class="fc" id="L752">	   	 permissionSet--;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">	   	 while (permissionSet != 0) {</span>
<span class="fc" id="L754">	   		permissionSet = permissionSet &gt;&gt;&gt; 1;</span>
<span class="fc" id="L755">   	 		permissionIdentifier++;</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">	   	 	 if ((permissionSet &amp; 1) != 0) {</span>
<span class="fc" id="L757">	   	 		 mySet.add(Integer.valueOf(permissionIdentifier));</span>
	   	 	 }
	   	 }
	   	 
<span class="fc" id="L761">	   	 return mySet;</span>
   	 
    }
    
    /**
     * Return the sets of admin permissions allowed to a subject, based on all the Access Tokens for that subject
     * 
     * @param subject   Subject identity of the node
     * @param groupName   Group name of the OSCORE group, or null to retrieve all the admin scope entries
     * @return The sets of scope entries such the group name matches with the specified group name pattern
     *         and for which the subject has admin permissions, or null in case of no results
     */
    public static CBORObject[] getGroupOSCOREAdminPermissionsFromToken(String subject, String groupName) {

<span class="fc" id="L775">    	List&lt;CBORObject&gt; scopeEntries = new ArrayList&lt;CBORObject&gt;();</span>
    	
<span class="fc" id="L777">    	String kid = TokenRepository.getInstance().getKid(subject);</span>
<span class="fc" id="L778">    	Set&lt;String&gt; ctis = TokenRepository.getInstance().getCtis(kid);</span>
    	
    	// This should never happen at this point, since a valid Access Token
    	// has just made this request pass through 
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">    	if (ctis == null)</span>
<span class="nc" id="L783">    		return null;</span>
    	
<span class="fc bfc" id="L785" title="All 2 branches covered.">    	for (String cti : ctis) { // All tokens linked to that pop key</span>
    		
	        // Check if we have the claims for that cti
    		
	        // Get the claims
<span class="fc" id="L790">            Map&lt;Short, CBORObject&gt; claims = TokenRepository.getInstance().getClaims(cti);</span>
<span class="pc bpc" id="L791" title="2 of 4 branches missed.">            if (claims == null || claims.isEmpty()) {</span>
                // No claims found
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L794">                continue;</span>
            }
            
	        //Check the scope
<span class="fc" id="L798">            CBORObject scope = claims.get(Constants.SCOPE);</span>
            
        	// This should never happen, since a valid Access Token
            // has just reached a handler at the Group Manager
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">            if (scope == null) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L804">            	continue;</span>
            }
            
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            if (!scope.getType().equals(CBORType.ByteString)) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L809">            	continue;</span>
            }
            
<span class="fc" id="L812">            byte[] rawScope = scope.GetByteString();</span>
<span class="fc" id="L813">        	CBORObject cborScope = CBORObject.DecodeFromBytes(rawScope);</span>
        	
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">        	if (!cborScope.getType().equals(CBORType.Array)) {</span>
        		// Move to the next Access Token for this 'kid'
<span class="nc" id="L817">                continue;</span>
            }
        	
<span class="fc bfc" id="L820" title="All 2 branches covered.">        	for (int entryIndex = 0; entryIndex &lt; cborScope.size(); entryIndex++) {</span>
            	
<span class="fc" id="L822">        		CBORObject scopeEntry = cborScope.get(entryIndex);</span>
        		
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">        		if (!scopeEntry.getType().equals(CBORType.Array) || scopeEntry.size() != 2) {</span>
        			// Move to the next Access Token for this 'kid'
<span class="nc" id="L826">                    break;</span>
                }
        		
	      	  	// Retrieve the role or list of admin permissions
<span class="fc" id="L830">        		CBORObject scopeElement = scopeEntry.get(1);</span>
	      	  	
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">	        	if (!scopeElement.getType().equals(CBORType.Integer)) {</span>
      	  		    // Move to the next scope entry
<span class="nc" id="L834">      	  			continue;</span>
	        	}
	        	
<span class="fc" id="L837">        		int permissionSetToken = scopeElement.AsInt32();</span>
        		
        		// According to the AIF-OSCORE-GROUPCOMM data model, a valid combination 
        		// of admin permissions has to be a positive integer of odd value (i.e., with last bit 1)
<span class="pc bpc" id="L841" title="1 of 4 branches missed.">        		if (permissionSetToken &lt;= 0 || (permissionSetToken % 2 == 0)) {</span>
      	  		    // Move to the next scope entry
<span class="fc" id="L843">      	  			continue;</span>
        		}
        		
<span class="fc bfc" id="L846" title="All 2 branches covered.">	      	  	if (groupName == null) {</span>
	      	  		// Include this scope entry in the results to return, and move to the next one
<span class="fc" id="L848">	      	  		scopeEntries.add(scopeEntry);</span>
<span class="fc" id="L849">	      	  		continue;</span>
	      	  	}

	        	// Check if the group name of the OSCORE group matches with the group name pattern
<span class="fc" id="L853">	      	  	scopeElement = scopeEntry.get(0);</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">	      	    if (matchingGroupOscoreName(groupName, scopeElement)) {</span>
	      	    	// There is a match; include this scope entry in the results to return
<span class="fc" id="L856">	      	    	scopeEntries.add(scopeEntry);</span>
	      	    }
	      	    else {
	      	    	// Move to the next scope entry
	      	    	continue;
	      	    }
        			        	
        	}
        	
<span class="fc" id="L865">    	}</span>
    	    	
    	// No Access Token allows this node to have any admin permission,
    	// altogether or with respect to the specified group
<span class="fc" id="L869">    	int size = scopeEntries.size();</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">    	if (size == 0) {</span>
<span class="nc" id="L871">    		return null;</span>
    	}
    	else {
<span class="fc" id="L874">    		CBORObject[] ret = new CBORObject[size];</span>
    		
<span class="fc" id="L876">    		int index = 0;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">    		for (CBORObject entry : scopeEntries) {</span>
        		// Hard copy
<span class="fc" id="L879">    			byte[] binaryElem = entry.EncodeToBytes();</span>
<span class="fc" id="L880">    			ret[index] = CBORObject.DecodeFromBytes(binaryElem);</span>
<span class="fc" id="L881">    			index++;</span>
<span class="fc" id="L882">    		}</span>
    		
<span class="fc" id="L884">    		return ret;</span>
    	}
    	
    }
    
    /**
     * Check if the name of an OSCORE group matches with the group name pattern
     * specified by Toid in a scope entry of the scope claim, according to the
     * AIF-OSCORE-GROUPCOMM data model
     *  
     * @param groupName   The name of the OSCORE group, as a String
     * @param groupNamePattern   The Toid from the scope entry, as a CBOR Object
     * @return  True if the group name matches with the group name pattern, or false otherwise
     */
    public static boolean matchingGroupOscoreName(final String groupName, final CBORObject groupNamePattern) {
    	
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">  	  	if (groupNamePattern.equals(CBORObject.True)) {</span>
	  		// The group name pattern is the wildcard
<span class="nc" id="L902">  	  		return true;</span>
  	  	}
  	  		
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">  	  	if (groupNamePattern.getType().equals(CBORType.TextString)) {</span>
<span class="fc" id="L906">  	  		String groupNamePatternString = groupNamePattern.AsString();</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">  	  		if (groupNamePattern.HasTag(21065)) {</span>
  	  			// The group name pattern is an I-Regexp regular expression
  	  			
<span class="nc" id="L910">  	  			Pattern pat = Pattern.compile(groupNamePatternString);</span>
<span class="nc" id="L911">  	  			Matcher myMatcher = pat.matcher(groupName);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">  	  			if (myMatcher.matches() == false) {</span>
  	  				// The target group name does not match with the regular expression
<span class="nc" id="L914">      	  		    return false;</span>
  	  			}
<span class="nc" id="L916">  	  		}</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">  	  		else if (!groupNamePatternString.equals(groupName)) {</span>
  	  			// The group name pattern is an exact group name,
  	  			// which does not match with the target group name
<span class="fc" id="L920">  	  		    return false;</span>
  	  		}
  	  		
  	  		// The target group name has matched with the group name pattern
<span class="fc" id="L924">  	  		return true;</span>
  	  	}

<span class="nc" id="L927">  	  	return false;</span>
  	  	
    }
    
    /**
     * Build a CWT Claims Set (CCS) including a COSE Key
     * within a &quot;cnf&quot; claim and an additional &quot;sub&quot; claim
     *  
     * @param identityKey   The public key as a OneKey object
     * @param subjectName   The subject name associated to this key, it can be an empty string
     * @return  The serialization of the CCS, or null in case of errors
     */
	public static byte[] oneKeyToCCS(OneKey identityKey, String subjectName) {
		
<span class="nc bnc" id="L941" title="All 4 branches missed.">		if (identityKey  == null || subjectName == null)</span>
<span class="nc" id="L942">			return null;</span>
		
<span class="nc" id="L944">		CBORObject coseKeyMap = CBORObject.NewMap();</span>
<span class="nc" id="L945">		coseKeyMap.Add(KeyKeys.KeyType.AsCBOR(), identityKey.get(KeyKeys.KeyType));</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">		if (identityKey.get(KeyKeys.KeyType) == KeyKeys.KeyType_OKP) {</span>
<span class="nc" id="L947">			int curve = identityKey.get(KeyKeys.OKP_Curve).AsInt32();</span>
<span class="nc bnc" id="L948" title="All 4 branches missed.">			if (curve == KeyKeys.OKP_Ed25519.AsInt32() || curve == KeyKeys.OKP_Ed448.AsInt32()) {</span>
<span class="nc" id="L949">				coseKeyMap.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.EDDSA.AsCBOR());</span>
			}
<span class="nc bnc" id="L951" title="All 4 branches missed.">			if (curve == KeyKeys.OKP_X25519.AsInt32() || curve == KeyKeys.OKP_X448.AsInt32()) {</span>
<span class="nc" id="L952">				coseKeyMap.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.ECDH_ES_HKDF_256.AsCBOR());</span>
			}
<span class="nc" id="L954">			coseKeyMap.Add(KeyKeys.OKP_Curve.AsCBOR(), identityKey.get(KeyKeys.OKP_Curve));</span>
<span class="nc" id="L955">			coseKeyMap.Add(KeyKeys.OKP_X.AsCBOR(), identityKey.get(KeyKeys.OKP_X));</span>
<span class="nc" id="L956">		}</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">		else if (identityKey.get(KeyKeys.KeyType) == KeyKeys.KeyType_EC2) {</span>
<span class="nc" id="L958">			int curve = identityKey.get(KeyKeys.EC2_Curve).AsInt32();</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">			if (curve == KeyKeys.EC2_P256 .AsInt32()) {</span>
<span class="nc" id="L960">				coseKeyMap.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.ECDSA_256.AsCBOR());</span>
			}
<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (curve == KeyKeys.EC2_P384 .AsInt32()) {</span>
<span class="nc" id="L963">				coseKeyMap.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.ECDSA_384.AsCBOR());</span>
			}
<span class="nc bnc" id="L965" title="All 2 branches missed.">			if (curve == KeyKeys.EC2_P521.AsInt32()) {</span>
<span class="nc" id="L966">				coseKeyMap.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.ECDSA_512.AsCBOR());</span>
			}
<span class="nc" id="L968">			coseKeyMap.Add(KeyKeys.EC2_Curve.AsCBOR(), identityKey.get(KeyKeys.EC2_Curve));</span>
<span class="nc" id="L969">			coseKeyMap.Add(KeyKeys.EC2_X.AsCBOR(), identityKey.get(KeyKeys.EC2_X));</span>
<span class="nc" id="L970">			coseKeyMap.Add(KeyKeys.EC2_Y.AsCBOR(), identityKey.get(KeyKeys.EC2_Y));</span>
<span class="nc" id="L971">		}</span>
		else {
<span class="nc" id="L973">			return null;</span>
		}
		
<span class="nc" id="L976">		CBORObject cnfMap = CBORObject.NewMap();</span>
<span class="nc" id="L977">		cnfMap.Add(Constants.COSE_KEY, coseKeyMap);</span>
		
<span class="nc" id="L979">		CBORObject claimSetMap = CBORObject.NewMap();</span>
<span class="nc" id="L980">		claimSetMap.Add(Constants.SUB, subjectName);</span>
<span class="nc" id="L981">		claimSetMap.Add(Constants.CNF, cnfMap);</span>
		
		// Debug print
<span class="nc" id="L984">		System.out.println(claimSetMap);</span>
		
<span class="nc" id="L986">        return claimSetMap.EncodeToBytes();</span>
		
	}
	
    /**
     * Extract a public key from a CWT Claims Set (CCS) and return it as a OneKey object
     *  
     * @param ccs   The CCS as a CBOR map
     * @return  The public key as a OneKey object, or null in case of errors
     */
	public static OneKey ccsToOneKey(CBORObject ccs) {
		
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">		if (ccs == null)</span>
<span class="nc" id="L999">			return null;</span>
		
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">		if (ccs.getType() != CBORType.Map)</span>
<span class="nc" id="L1002">		    return null;</span>
		
<span class="pc bpc" id="L1004" title="2 of 4 branches missed.">		if (!ccs.ContainsKey(Constants.CNF) || !ccs.get(Constants.CNF).ContainsKey(Constants.COSE_KEY))</span>
<span class="nc" id="L1005">			return null;</span>
		
<span class="fc" id="L1007">		CBORObject pubKeyCBOR = ccs.get(Constants.CNF).get(Constants.COSE_KEY);</span>
		
<span class="fc" id="L1009">		OneKey pubKey = null;</span>
		try {
<span class="fc" id="L1011">			pubKey = new OneKey(pubKeyCBOR);</span>
<span class="nc" id="L1012">		} catch (CoseException e) {</span>
<span class="nc" id="L1013">			System.err.println(&quot;Error when building a OneKey from a CCS: &quot; + e.getMessage());</span>
<span class="nc" id="L1014">			return null;</span>
<span class="fc" id="L1015">		}</span>
		
<span class="fc" id="L1017">        return pubKey;</span>
		
	}
	
    /**
     * @param byteArray  the byte array
     * @return  the hex string
     * 
     * Return the printable hexadecimal string corresponding to a byte array
     */
    public static String byteArrayToHexString(final byte[] byteArray) {
    	
<span class="nc bnc" id="L1029" title="All 2 branches missed.">    	if (byteArray == null) {</span>
<span class="nc" id="L1030">    		return new String(&quot;&quot;);</span>
    	}
    	else {
<span class="nc" id="L1033">    		String str = new String(&quot;&quot;);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">	    	for (byte byteToConvert: byteArray) {</span>
<span class="nc" id="L1035">	            str += String.format(&quot;%02X&quot;, byteToConvert);</span>
	        }
<span class="nc" id="L1037">	    	return str;</span>
    	}
    	
    }
	
    /**
     * Read a hex string and transform to bytes
     * 
     * @param hex  the hex string
     * @return  the byte array representation
     */
    public static byte[] hexString2byteArray(String hex) {
<span class="fc" id="L1049">        int len = hex.length();</span>
<span class="fc" id="L1050">        byte[] data = new byte[len / 2];</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i += 2) {</span>
<span class="fc" id="L1052">            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) &lt;&lt; 4)</span>
<span class="fc" id="L1053">                    + Character.digit(hex.charAt(i+1), 16));</span>
        }
<span class="fc" id="L1055">        return data;</span>
    }
	
    /**
     * Build a CBOR map specifying a public key, possibly together with the corresponding private key
     * 
     * @param signKeyCurve  the curve of the signature algorithm
     * @param x  the x-coordinate of the public key
     * @param y  the y-coordinate of the public key, or null if not applicable
     * @param d  the private key, or null if the CBOR map specifies only the public key
     * @return  The CBOR map specifying a public key, possibly together with the corresponding private key
     */
    public static CBORObject buildRpkData (int signKeyCurve, String x, String y, String d) {
    	
<span class="fc" id="L1069">    	CBORObject rpkData = CBORObject.NewMap();</span>
    	
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">    	if (signKeyCurve == KeyKeys.EC2_P256.AsInt32()) {</span>
<span class="fc" id="L1072">	        rpkData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_EC2);</span>
<span class="fc" id="L1073">	        rpkData.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.ECDSA_256.AsCBOR());</span>
<span class="fc" id="L1074">	        rpkData.Add(KeyKeys.EC2_Curve.AsCBOR(), KeyKeys.EC2_P256);</span>
<span class="fc" id="L1075">	        CBORObject Cx = CBORObject.FromObject(hexString2byteArray(x));</span>
<span class="fc" id="L1076">	        CBORObject Cy = CBORObject.FromObject(hexString2byteArray(y));</span>
<span class="fc" id="L1077">	        rpkData.Add(KeyKeys.EC2_X.AsCBOR(), Cx);</span>
<span class="fc" id="L1078">	        rpkData.Add(KeyKeys.EC2_Y.AsCBOR(), Cy);</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">	        if (d != null) {</span>
<span class="fc" id="L1080">		        CBORObject Cd = CBORObject.FromObject(hexString2byteArray(d));</span>
<span class="fc" id="L1081">		        rpkData.Add(KeyKeys.EC2_D.AsCBOR(), Cd);</span>
	        }
    	}
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">    	if (signKeyCurve == KeyKeys.OKP_Ed25519.AsInt32()) {</span>
<span class="nc" id="L1085">	        rpkData.Add(KeyKeys.KeyType.AsCBOR(), KeyKeys.KeyType_OKP);</span>
<span class="nc" id="L1086">	        rpkData.Add(KeyKeys.Algorithm.AsCBOR(), AlgorithmID.EDDSA.AsCBOR());</span>
<span class="nc" id="L1087">	        rpkData.Add(KeyKeys.OKP_Curve.AsCBOR(), KeyKeys.OKP_Ed25519);</span>
<span class="nc" id="L1088">	        CBORObject Cx = CBORObject.FromObject(hexString2byteArray(x));</span>
<span class="nc" id="L1089">	        rpkData.Add(KeyKeys.OKP_X.AsCBOR(), Cx);</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">	        if (d != null) {</span>
<span class="nc" id="L1091">		        CBORObject Cd = CBORObject.FromObject(hexString2byteArray(d));</span>
<span class="nc" id="L1092">		        rpkData.Add(KeyKeys.OKP_D.AsCBOR(), Cd);</span>
	        }
    	}
        
<span class="fc" id="L1096">    	return rpkData;</span>
    }
    
    /**
     * Return the used major version of Java
     * 
     * @return  The used major version of Java
     */
    public static int getJavaVersion() {
<span class="nc" id="L1105">        String version = System.getProperty(&quot;java.version&quot;);</span>
        
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if(version.startsWith(&quot;1.&quot;)) {</span>
<span class="nc" id="L1108">            version = version.substring(2, 3);</span>
        } else {
<span class="nc" id="L1110">            int dot = version.indexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">            if(dot != -1) {</span>
<span class="nc" id="L1112">            	version = version.substring(0, dot);</span>
            }
        }
        
<span class="nc" id="L1116">        return Integer.parseInt(version);</span>
    }
    
    public static void prettyPrintCborMap(final CBORObject obj) {

<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">    	if (obj.getType() != CBORType.Map) {</span>
<span class="nc" id="L1122">    		System.err.println(&quot;Trying to print a CBOR map, while it is not&quot;);</span>
<span class="nc" id="L1123">    		return;</span>
    	}
    	
<span class="fc" id="L1126">    	int counter = 0;</span>
<span class="fc" id="L1127">    	System.out.println(&quot;{&quot;);</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">    	for (CBORObject elemKey : obj.getKeys()) {</span>
<span class="fc" id="L1129">    		System.out.print(&quot;  &quot; + elemKey + &quot;: &quot; + obj.get(elemKey));</span>
<span class="fc" id="L1130">    		counter++;</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">    		if (counter != obj.size()) {</span>
<span class="fc" id="L1132">    			System.out.println(&quot;,&quot;);</span>
    		}
    		else {
<span class="fc" id="L1135">    			System.out.println(&quot;&quot;);</span>
    		}
<span class="fc" id="L1137">    	}</span>
<span class="fc" id="L1138">    	System.out.println(&quot;}\n&quot;);</span>
    	
<span class="fc" id="L1140">    }</span>
    
    public static void printResponsePayloadCBOR(Response res) throws Exception {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (res != null) {</span>
<span class="nc" id="L1144">            System.out.print(res.getCode().codeClass + &quot;.0&quot; + res.getCode().codeDetail);</span>
<span class="nc" id="L1145">            System.out.println(&quot; &quot; + res.getCode().name());</span>

<span class="nc" id="L1147">            int contentFormat = res.getOptions().getContentFormat();</span>
<span class="nc" id="L1148">            byte[] payload = res.getPayload();</span>
            
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (payload != null) {</span>
<span class="nc bnc" id="L1151" title="All 6 branches missed.">                if (contentFormat == Constants.APPLICATION_ACE_CBOR ||</span>
                	  contentFormat == Constants.APPLICATION_ACE_GROUPCOMM_CBOR ||
                	  contentFormat == Constants.APPLICATION_CONCISE_PROBLEM_DETAILS_CBOR) {
<span class="nc" id="L1154">                    CBORObject resCBOR = CBORObject.DecodeFromBytes(payload);</span>
<span class="nc" id="L1155">                    System.out.println(resCBOR.toString());</span>
<span class="nc" id="L1156">                }</span>
                else {
<span class="nc" id="L1158">                    System.out.println(new String(payload));</span>
                }
            }
<span class="nc" id="L1161">        } else {</span>
<span class="nc" id="L1162">            System.out.println(&quot;The response has a null payload!&quot;);</span>
        }
<span class="nc" id="L1164">    }</span>
    
    /**
     * Returns the size in bytes of the nonce of a COSE encryption algorithm
     * 
     * @param alg  the encryption algorithm
     * @return  The size in bytes of the encryption algorithm, or -1 in case of error
     */
    public static int getSizeOfAlgNonce(final AlgorithmID alg) {
    	
<span class="pc bpc" id="L1174" title="3 of 4 branches missed.">    	switch (alg) {</span>
    		case AES_GCM_128:
    		case AES_GCM_192:
    		case AES_GCM_256:
<span class="nc" id="L1178">    			return 12;</span>
    		case AES_CCM_16_64_128:
    		case AES_CCM_16_64_256:
    		case AES_CCM_16_128_128:
    		case AES_CCM_16_128_256:
<span class="fc" id="L1183">    			return 13;</span>
    		case AES_CCM_64_64_128:
    		case AES_CCM_64_64_256:
    		case AES_CCM_64_128_128:
    		case AES_CCM_64_128_256:
<span class="nc" id="L1188">    			return 7;</span>
    		default:
<span class="nc" id="L1190">    			return -1;</span>
    	}
    	
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>